<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_the_expression_factory"><a id="the_expression_factory"/><h3 class="docSection1Title">B.1. The Expression Factory</h3><p class="docText">Hibernate provides the class <tt>net.sf.hibernate.expression.Expression</tt> as a factory for creating the <tt>Criterion</tt> instances you use to set up criteria queries. <tt>Expression</tt> defines a bunch of static methods you can invoke to conveniently create each of the standard <tt>Criterion</tt> implementations available in Hibernate, using parameters you supply. These criteria are used to determine which persistent objects from the database are included in the results of your query. Here is a summary of the available options.<a id="idx-APP-B-0350"/></p><a id="the_expression_factoryd1e9783"/><table cellspacing="0" border="1" width="100%"><colgroup span="3"><col/><col/><col/></colgroup><thead><tr><th scope="col" class="docTableCell thead">Method</th><th scope="col" class="docTableCell thead">Parameters</th><th scope="col" class="docTableCell thead">Purpose</th></tr></thead><tbody><tr><td class="docTableCell"><tt>allEq</tt></td><td class="docTableCell"><tt>Map properties</tt></td><td class="docTableCell">A shortcut for requiring several properties to have particular values. The keys of the supplied map are the names of the properties you want to constrain, while the values in the map are the target values each property must equal if an entity is to be included in the query results. The returned <tt>Criterion</tt> ensures that each named property has the corresponding value.</td></tr><tr><td class="docTableCell"><tt>and</tt></td><td class="docTableCell"><tt>Criterion lhs, Criterion rhs</tt></td><td class="docTableCell"><a id="compound"/>Builds a compound <tt>Criterion</tt> that requires both halves to be met in order for the whole to succeed.</td></tr><tr><td class="docTableCell"><tt>between</tt></td><td class="docTableCell"><tt>String property, Object low, Object high</tt></td><td class="docTableCell">Requires the value of the named property to fall between the values of <tt>low</tt> and <tt>high</tt>.</td></tr><tr><td class="docTableCell"><tt>conjunction</tt></td><td class="docTableCell">None</td><td class="docTableCell">Creates a <tt>Conjunction</tt> object which can be used to build an "and" criterion with as many pieces as you need. Simply call its <tt>add</tt>() method with each of the <tt>Criterion</tt> instances you want to check. The conjunction will be true if and only all its component criteria are true. This is more convenient than building a tree of <tt>and</tt>() criteria "by hand." The <tt>add</tt>() method of the <tt>Criteria</tt> interface acts as though it contains a <tt>Conjunction</tt>.</td></tr><tr><td class="docTableCell"><tt>disjunction</tt></td><td class="docTableCell">None</td><td class="docTableCell">Creates a <tt>Disjunction</tt> object that can be used to build an "or" criterion with as many pieces as you need. Simply call its <tt>add</tt>() method with each of the <tt>Criterion</tt> instances you want to check. The disjunction will be true if any of its component criteria are true. This is more convenient than building a tree of <tt>or</tt>() criteria "by hand." See <a class="docLink" href="0596006969_compounding_criteria.xhtml#picking_tracks_more_leniently">Example 8-10</a>.</td></tr><tr><td class="docTableCell"><tt>eq</tt></td><td class="docTableCell"><tt>String property, Object value</tt></td><td class="docTableCell">Requires the named property to have the specified value.</td></tr><tr><td class="docTableCell"><tt>eqProperty</tt></td><td class="docTableCell"><tt>String property1, String property2</tt></td><td class="docTableCell">Requires the two named properties to have the same value.</td></tr><tr><td class="docTableCell"><tt>ge</tt></td><td class="docTableCell"><tt>String property, Object value</tt></td><td class="docTableCell">Requires the named property to be greater than or equal to the specified value.</td></tr><tr><td class="docTableCell"><tt>gt</tt></td><td class="docTableCell"><tt>String property, Object value</tt></td><td class="docTableCell">Requires the named property to be greater than the specified value.</td></tr><tr><td class="docTableCell"><tt>ilike</tt></td><td class="docTableCell"><tt>String property, String value</tt></td><td class="docTableCell">A case-insensitive "like" operator. See like, below.</td></tr><tr><td class="docTableCell"><tt>ilike</tt></td><td class="docTableCell"><tt>String property, String value, MatchMode mode</tt></td><td class="docTableCell">A case-insensitive "like" operator for people who don't want to mess with "like" syntax and just want to match a substring. <tt>MatchMode</tt> is a type-safe enumeration with values <tt>START, END, ANYWHERE</tt>, and <tt>EXACT</tt>. This method simply adjusts the syntax of <tt>value</tt> to reflect the kind of matching specified by <tt>mode</tt>, then calls the two-parameter <tt>ilike</tt>().</td></tr><tr><td class="docTableCell"><tt>in</tt></td><td class="docTableCell"><tt>String property, Collection values</tt></td><td class="docTableCell">A shortcut for allowing the named property to have any of the values contained in the collection. This is more convenient than building up a <tt>disjunction</tt>() of <tt>eq</tt>() criteria "by hand."</td></tr><tr><td class="docTableCell"><tt>in</tt></td><td class="docTableCell"><tt>String property, Object[] values</tt></td><td class="docTableCell">A shortcut for allowing the named property to have any of the values contained in the array. This is more convenient than building up a <tt>disjunction</tt>() of <tt>eq</tt>() criteria "by hand."</td></tr><tr><td class="docTableCell"><tt>isNotNull</tt></td><td class="docTableCell"><tt>String property</tt></td><td class="docTableCell">Requires the named property to have a value other than <tt>null</tt>.</td></tr><tr><td class="docTableCell"><tt>isNull</tt></td><td class="docTableCell"><tt>String property</tt></td><td class="docTableCell">Requires the named property to be <tt>null</tt>.</td></tr><tr><td class="docTableCell"><tt>isNull</tt></td><td class="docTableCell"><tt>String property</tt></td><td class="docTableCell">Requires the named property to be <tt>null</tt>.</td></tr><tr><td class="docTableCell"><tt>le</tt></td><td class="docTableCell"><tt>String property, Object value</tt></td><td class="docTableCell">Requires the named property to be less than or equal to the specified value. See <a class="docLink" href="0596006969_using_simple_criteria.xhtml#the_criteria_query_that_fully_replaces_t">Example 8-3</a>.</td></tr><tr><td class="docTableCell"><tt>leProperty</tt></td><td class="docTableCell"><tt>String property1, String property2</tt></td><td class="docTableCell">Requires the first named property to be less than or equal to the second.</td></tr><tr><td class="docTableCell"><tt>like</tt></td><td class="docTableCell"><tt>String property, String value</tt></td><td class="docTableCell">Requires the named property to be "like" the specified value (in the sense of the SQL <tt>like</tt> operator, which allows simple pattern matching). See <a class="docLink" href="0596006969_compounding_criteria.xhtml#a_pickier_list_of_short_tracks">Example 8-8</a> and <a class="docLink" href="0596006969_using_simple_criteria.xhtml#the_criteria_query_that_fully_replaces_t">Example 8-3</a>.</td></tr><tr><td class="docTableCell"><tt>like</tt></td><td class="docTableCell"><tt>String property, String value, MatchMode mode</tt></td><td class="docTableCell">A "like" operator for people who don't want to mess with "like" syntax and just want to match a substring. <tt>MatchMode</tt> is a type-safe enumeration with values <tt>START, END, ANYWHERE</tt>, and <tt>EXACT</tt>. This method simply adjusts the syntax of <tt>value</tt> to reflect the kind of matching specified by <tt>mode</tt>, then calls the two-parameter <tt>like</tt>().</td></tr><tr><td class="docTableCell"><tt>lt</tt></td><td class="docTableCell"><tt>String property, Object value</tt></td><td class="docTableCell">Requires the named property to be less than the specified value.</td></tr><tr><td class="docTableCell"><tt>ltProperty</tt></td><td class="docTableCell"><tt>String property1, String property2</tt></td><td class="docTableCell">Requires the first named property to be less than the second.</td></tr><tr><td class="docTableCell"><tt>not</tt></td><td class="docTableCell"><tt>Criterion value</tt></td><td class="docTableCell">Negates the supplied <tt>Criterion</tt> (if it matched, this one fails, and vice versa).</td></tr><tr><td class="docTableCell"><tt>or</tt></td><td class="docTableCell"><tt>Criterion lhs, Criterion rhs</tt></td><td class="docTableCell">Builds a compound <tt>Criterion</tt> that succeeds if either of its halves matches.</td></tr><tr><td class="docTableCell"><tt>sql</tt></td><td class="docTableCell"><tt>String sql</tt></td><td class="docTableCell">Apply a constraint expressed in the native SQL dialect of the underlying database system. This can be very powerful, but be aware it might lead to loss of portability.</td></tr><tr><td class="docTableCell"><tt>sql</tt></td><td class="docTableCell"><tt>String sql, Object value, Type type</tt></td><td class="docTableCell">Apply a constraint expressed in the native SQL of the underlying database, with the supplied JDBC parameters. This can be very powerful, but be aware it might lead to loss of portability.</td></tr><tr><td class="docTableCell"><tt>sql</tt></td><td class="docTableCell"><tt>String sql, Object value, Type type</tt></td><td class="docTableCell">Apply a constraint expressed in the native SQL of the underlying database, with the supplied JDBC parameters. This can be very powerful, but be aware it might lead to loss of portability.</td></tr></tbody></table><br/><p class="docText">When specifying query text for the <tt>sql</tt>() methods, any occurrences of the string "{<tt>alias</tt>}" within the query will be replaced by the actual alias of the table on which the query is being performed.</p><p class="docText">Many of these methods accept <tt>Criterion</tt> instances as arguments, allowing you to build compound criteria trees of as much complexity as you need. <tt>conjunction</tt><a id="and"/>() and <tt>disjunction</tt>() return objects that make it even easier to add criteria, by returning objects with <tt>add</tt>() methods you can call as many times as you'd like to add criteria. If your query gets sufficiently complex, however, it might be easier to express and understand in HQL. There are also some kinds of queries that are not yet supported by this API, so you may not always be able to avoid HQL even if you want to.</p><p class="docText">Despite these caveats, many of the kinds of bread-and-butter queries that come up all the time in application development are expressed very naturally and easily in this API, leading to readable and compact Java code.</p></div></div></body>
</html>