<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_better_ways_to_build_queries"><a id="better_ways_to_build_queries"/><h3 class="docSection1Title">3.3. Better Ways to Build Queries</h3><p class="docText">As mentioned earlier, HQL lets you go beyond the use of JDBC-style query placeholders to get parameters conveniently into your queries. The features discussed in this section can make your programs much easier to read and maintain.</p><p class="docText">Use named parameters to control queries and move the query text completely outside of your Java source code.</p><a id="why_do_i_care-id004"/><h4 id="title-ID0EPYAE" class="docSection2Title">3.3.1. Why do I care?</h4><p class="docText">Well, I've already promised that this will make your programs easier to write, read, and update. In fact, if these features weren't available in Hibernate, I would have been less eager to adopt it, because they've been part of my own (even more) lightweight O/R layer for years.</p><p class="docText">Named parameters make code easier to understand because the purpose of the parameter is clear both within the query itself and within the Java code that is setting it up. This self-documenting nature is valuable in itself, but it also reduces the potential for error by freeing you from counting commas and question marks, and it can modestly improve efficiency by letting you use the same parameter more than once in a single query.</p><p class="docText">Keeping the queries out of Java source code makes them <span class="docEmphasis">much</span> easier to read and edit because they aren't giant concatenated series of Java strings spread across multiple lines and interleaved with extraneous quotation marks, backslashes, and other Java punctuation. Typing them the first time is bad enough, but if you've ever had to perform significant surgery on a query embedded in a program in this way, you will have had your fill of moving quotation marks and plus signs around to try to get the lines to break in nice places again.</p><blockquote><p class="docText"><span class="docEmphasis">If you haven't yet had to deal with this, trust me, it's well worth avoiding</span>.</p></blockquote><a id="how_do_i_do_that-id010"/><h4 id="title-ID0E4YAE" class="docSection2Title">3.3.2. How do I do that?</h4><p class="docText">The key to both of these capabilities in Hibernate is the <tt>Query</tt> interface. We'll start by changing our query to use a named parameter (<a class="docLink" href="#revising_our_query_to_use_a_named_parame">Example 3-8</a>). (This isn't nearly as big a deal for a query with a single parameter like this one, but it's worth getting into the habit right away. You'll be very thankful when you start working with the light-dimming <a id="idx-CHP-3-0142"/>queries that power your real projects!)<a id="idx-CHP-3-0143"/></p><a id="revising_our_query_to_use_a_named_parame"/><h5 id="title-ID0EUZAE" class="docExampleTitle">Example 3-8. Revising our query to use a named parameter</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
public static List tracksNoLongerThan(Time length, Session session)
    throws HibernateException
{
    Query query = session.createQuery("from com.oreilly.hh.Track as track " +
                                      "where track.playTime &lt;= :length");
    query.setTime("length", length);
    return query.list();
}
</pre><br/>
</td></tr></table><p class="docText">Named parameters are identified within the query body by prefixing them with a colon. Here, we've changed the "?" to <tt>":length"</tt>. The <tt>Session</tt><a id="a"/> object provides a <tt>createQuery()</tt> method that gives us back an implementation of the <tt>Query</tt> interface with which we can work. <tt>Query</tt> has a full complement of type-safe methods for setting the values of named parameters. Here we are passing in a <tt>Time</tt><a id="use"/> value, so we use <tt>setTime()</tt>. Even in a simple case like this, the syntax is more natural and readable than the original version of our query. If we had been passing in anonymous arrays of values and types (as would have been necessary with more than one parameter), the improvement would be even more significant. And we've added a layer of compile-time type checking, always a welcome change.</p><p class="docText">Running this version produces the same output as our original program.</p><p class="docText">So how do we get the query text out of the Java source? Again, this query is short enough that the need to do so isn't as pressing as usual in real projects, but it's the best way to do things, so let's start practicing! As you may have predicted, the place we can store queries is inside the mapping document. <a class="docLink" href="#our_query_in_the_mapping_document">Example 3-9</a> shows what it looks like (we have to use the somewhat clunky <tt>CDATA</tt> construct since our query contains characters—like "&lt;"—that could otherwise confuse the XML parser).</p><a id="our_query_in_the_mapping_document"/><h5 id="title-ID0E21AE" class="docExampleTitle">Example 3-9. Our query in the mapping document</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
&lt;query name="com.oreilly.hh.tracksNoLongerThan"&gt;
  &lt;![CDATA[
      from com.oreilly.hh.Track as track
      where track.playTime &lt;= :length
    ]]&gt;
&lt;/query&gt;
</pre><br/>
</td></tr></table><p class="docText">Put this just after the closing tag of the class definition in <span class="docEmphasis">Track.hbm.xml</span> (right before the <tt>&lt;/hibernate-mapping&gt;</tt> line). Then we can revise <span class="docEmphasis">QueryTest.java</span> one last time, as shown in <a class="docLink" href="#the_final_version_of_our_query_method">Example 3-10</a>. Once again, the program produces exactly the same output as the initial version. It's just better organized now, and we're in great shape if we ever want to make the query more complex.</p><a id="the_final_version_of_our_query_method"/><h5 id="title-ID0EO2AE" class="docExampleTitle">Example 3-10. The final version of our query method</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
public static List tracksNoLongerThan(Time length, Session session)
    throws HibernateException
{
    Query query = session.getNamedQuery(
                      "com.oreilly.hh.tracksNoLongerThan");
    query.setTime("length", length);
    return query.list();
}
</pre><br/>
</td></tr></table><p class="docText">The <tt>Query</tt> interface has other useful capabilities beyond what we've examined here. You can use it to control how many rows (and which specific rows) you retrieve. If your JDBC driver supports scrollable <tt>ResultSets</tt>, you can access this capability as well. Check the JavaDoc or the Hibernate reference manaual for more details.</p><a id="what_abouthellip-id007"/><h4 id="title-ID0E32AE" class="docSection2Title">3.1.3. What about…</h4><p class="docText">…Avoiding a SQL-like language altogether? Or diving in to HQL and exploring more complex queries? These are both options that are covered later in the book.</p><p class="docText"><a class="docLink" href="0596006969_criteria_queries.xhtml#criteria_queries">Chapter 8</a> discusses criteria queries, an interesting mechanism that lets you express the constraints on the entities you want, using a natural Java API. This gives you the benefits of compile-time syntax checking, and easy dynamic configuration, all in the language you're already using to code your application. It also supports a form of "query by example," where you can supply objects that are similar to the ones you're searching for.</p><p class="docText">SQL veterans who'd like to see more tricks with HQL can jump to <a class="docLink" href="0596006969_a_look_at_hql.xhtml#a_look_at_hql">Chapter 9</a>, which explores more of its capabilities and unique features.</p><p class="docText">For now, we'll continue our examination of mapping by seeing how to represent groups and links between objects.</p></div></div></body>
</html>