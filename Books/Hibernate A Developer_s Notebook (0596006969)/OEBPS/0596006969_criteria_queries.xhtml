<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_criteria_queries"><a id="criteria_queries"/><h2 id="title-ID0ESABG" class="docChapterTitle">8. Criteria Queries</h2><p class="docText">Relational query languages like HQL (and SQL, on which it's based) are extremely flexible and powerful, but they take a long time to truly master. Many application developers get by with a rudimentary understanding, cribbing similar examples from past projects, and calling in database experts when they need to come up with something truly new, or to understand a particularly cryptic query expression.</p><blockquote><p class="docText"><span class="docEmphasis">In this chapter</span>:</p><ul><li><p class="docList"><span class="docEmphasis">Using Simple Criteria</span></p></li><li><p class="docList"><span class="docEmphasis">Compounding Criteria</span></p></li><li><p class="docList"><span class="docEmphasis">Applying Criteria to Associations</span></p></li><li><p class="docList"><span class="docEmphasis">Querying by Example</span></p></li></ul></blockquote><p class="docText">It can also be awkward to mix a query language's syntax with Java code. The section "Better Ways to Build Queries" in <a class="docLink" href="0596006969_harnessing_hibernate.xhtml#harnessing_hibernate">Chapter 3</a> showed how to at least keep the queries in a separate file so they can be seen and edited in one piece, free <a id="idx-CHP-8-0291"/>of Java string escape sequences and concatenation syntax. Even with that technique, though, the HQL isn't parsed until the mapping document is loaded, which means that any syntax errors it might harbor won't be caught until the application is running.</p><p class="docText">Hibernate offers an unusual solution to these problems in the form of criteria queries. They provide a way to create and connect simple Java objects that act as filters for picking your desired results. You can build up nested, structured expressions. The mechanism also allows you to supply example objects to show what you're looking for, with control over which details matter and which properties to ignore.</p><p class="docText">As you'll see, this can be quite convenient. To be fair, it has its own disadvantages. Expanding long query expressions into a Java API makes them take more room, and they'll be less familiar to experienced database developers than a SQL-like query. There are also some things you simply can't express using the current criteria API, such as <span class="docEmphasis">projection</span> (retrieving a subset of the properties of a class, e.g., "<tt>select title, id from com.oreilly.hh.Track</tt>" rather than "<tt>select * from com.oreilly. hh.Track</tt>") and <span class="docEmphasis">aggregation</span> (summarizing results, e.g., getting the sum, average, or count of a property). The next chapter shows how to accomplish such tasks using Hibernate's object-oriented query language.</p></div></div></body>
</html>