<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_lifecycle_associations"><a id="lifecycle_associations"/><h3 class="docSection1Title">5.4. Lifecycle Associations</h3><p class="docText">Hibernate is completely responsible for managing the <tt>ALBUM_TRACKS</tt> table, adding and deleting rows (and, if necessary, renumbering <tt>POSITION</tt> values) as entries are added to or removed from <tt>Album</tt> beans' <tt>tracks</tt> properties. You can test this by writing a test program to delete the second track from our test album and see the result. A very quick and dirty way to do this would be to add the following four lines (see <a class="docLink" href="#deleting_our_albums_second_track">Example 5-11</a>) right after the existing <tt>tx.commit()</tt> line in <a class="docLink" href="0596006969_augmenting_associations_in_collections.xhtml#source_of_albumtestjava">Example 5-7</a><a id="run"/> and then run <tt><b>ant schema ctest atest db</b></tt>.<a id="idx-CHP-5-0222"/><a id="I_indexterm5_d1e5127"/></p><a id="deleting_our_albums_second_track"/><h5 id="title-ID0EIPAG" class="docExampleTitle">Example 5-11. Deleting our album's second track</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
tx = session.beginTransaction();
album.getTracks().remove(1);
session.update(album);
tx.commit();
</pre><br/>
</td></tr></table><p class="docText">Doing so changes the contents of <tt>ALBUM_TRACKS</tt> as shown in <a class="docLink" href="#album_track_associations_after_deleting_">Figure 5-4</a> (compare this with the original contents in <a class="docLink" href="0596006969_augmenting_associations_in_collections.xhtml#our_augmented_collection_of_associations">Figure 5-3</a>). The second record has been removed (remember that Java list elements are indexed starting with zero), and <tt>POSITION</tt> has been adjusted so that it retains its consecutive nature, corresponding to the indices of the list elements (the values you'd use when calling <tt>tracks.get()</tt>).</p><a id="album_track_associations_after_deleting_"/><p/><div class="center"><h5 class="docFigureTitle">Figure 5-4. Album track associations after deleting our album's second track</h5><a id="I_mediaobject5_d1e5155"/><p class="docText"><img src="Images/0596006969_lifecycle_associations_image01.png" alt="" width="396" height="246"/></p></div><br/><p class="docText">This happens because Hibernate understands that this list is "owned" by the <tt>Album</tt> record, and that the "lifecycles" of the two objects are intimately connected. This notion of lifecycle becomes more clear if you consider what happens if the entire <tt>Album</tt> is deleted: all of the associated records in <tt>ALBUM_TRACKS</tt> will be deleted as well. (Go ahead and modify the test program to try this if you're not convinced.)</p><p class="docText">Contrast this with the relationship between the <tt>ALBUM</tt> table and the <tt>TRACK</tt> table. Tracks are sometimes associated with albums, but they are sometimes independent. Removing a track from the list got rid of a row in <tt>ALBUM_TRACKS</tt>, eliminating the link between the album and track, but didn't get rid of the row in <tt>TRACK</tt>, so it didn't delete the persistent <tt>Track</tt> object itself. Similarly, deleting the <tt>Album</tt> would eliminate all the associations in the collection, but none of the actual <tt>Tracks</tt>. It's the responsibility of our code to take care of that when appropriate (probably after consulting the user, in case any of the track records might be shared across multiple albums, as discussed above).</p><p class="docText">If we don't need the flexibility of sharing the same track between albums—disk space is pretty cheap lately given the size of compressed audio—we can let Hibernate manage the <tt>TRACK</tt> records for the album in the same way it does the <tt>ALBUM_TRACKS</tt> collection. It won't assume it should do this, because <tt>Track</tt> and <tt>Album</tt> objects can exist independently, but we can establish a lifecycle relationship between them in the album mapping document.</p><blockquote><p class="docText"><span class="docEmphasis">By now you're probably not surprised there's a way to automate this</span>.</p></blockquote><a id="how_do_i_do_that-id017"/><h4 id="title-ID0EASAG" class="docSection2Title">5.1.1. How do I do that?</h4><p class="docText"><a class="docLink" href="#establishing_a_lifecycle_relationship_be">Example 5-12</a> shows (in bold) the changes we'd make to the <tt>tracks</tt> property mapping in <span class="docEmphasis">Album.hbm.xml</span>.</p><a id="establishing_a_lifecycle_relationship_be"/><h5 id="title-ID0EOSAG" class="docExampleTitle">Example 5-12. Establishing a lifecycle relationship between an album and its tracks</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
&lt;list name="tracks" table="ALBUM_TRACKS" <b>cascade="all"</b>&gt;
  &lt;meta attribute="use-in-tostring"&gt;true&lt;/meta&gt;
  &lt;key column="ALBUM_ID"/&gt;
  &lt;index column="POSITION"/&gt;
  &lt;composite-element class="com.oreilly.hh.AlbumTrack"&gt;
    &lt;many-to-one name="track" class="com.oreilly.hh.Track" <b>cascade="all"</b>&gt;
      &lt;meta attribute="use-in-tostring"&gt;true&lt;/meta&gt;
      &lt;column name="TRACK_ID"/&gt;
    &lt;/many-to-one&gt;
    &lt;property name="disc" type="integer"/&gt;
    &lt;property name="positionOnDisc" type="integer"/&gt;
  &lt;/composite-element&gt;
&lt;/list&gt;
</pre><br/>
</td></tr></table><p class="docText">The <tt>cascade</tt> attribute tells Hibernate that you want operations performed
on a "parent" object to be transitively applied to its "child" or "dependent" objects. It's applicable to all forms of collections and associations. There are several possible values to choose among. The most common are <tt>none</tt> (the default), <tt>save-update, delete</tt><a id="combines"/>, and all (which combines <tt>save-update</tt> and <tt>delete</tt>). You can also change the default from <tt>none</tt> to <tt>save-update</tt><a id="a"/> throughout your entire mapping document by supplying a <tt>default-cascade</tt><a id="the"/> attribute in the <tt>hibernate-mapping</tt> tag itself.</p><p class="docText">In our example, we want the tracks owned by an album to be automatically managed by the album, so that when we delete the album, its tracks are deleted. Note that we need to apply the <tt>cascade</tt> attribute both to the <tt>tracks</tt> collection and its constituent <tt>track</tt><a id="a"/> element to achieve this. Also, by using a <tt>cascade</tt> value of all, we eliminate the need to explicitly save any <tt>Track</tt> objects we create for the album—the <tt>addAlbumTrack()</tt> method of <a class="docLink" href="0596006969_augmenting_associations_in_collections.xhtml#source_of_albumtestjava">Example 5-7</a> no longer needs the line:</p><pre>
	session.save(track);
</pre><br/>
<p class="docText">By telling Hibernate that it's fully responsible for the relationship between an album and its track, we enable it to persist tracks when they're added to the album as well as delete them when the album itself is deleted.</p><p class="docText">Delegating this sort of bookkeeping to the mapping layer can be very convenient, freeing you to focus on more abstract and important tasks, so it is worth using when appropriate. It's reminiscent of the liberation provided by Java's pervasive garbage collection, but it can't be as comprehensive because there is no definitive way to know when you're finished with persistent data by performing reachability analysis; you need to indicate it by calling <tt>delete()</tt> and establishing lifecycle connections. The trade-off between flexibility and simple automation is yours to make, based on the nature of your data and the needs of your project.</p><hr style="height: 1px; color: gray; background-color: gray;"/><p><span class="v2"><i><b>Warning:</b></i></span></p><p class="docText">Hibernate's management of lifecycle relationships is not foolproof—or perhaps it's more accurate to say it's not all-encompassing. For example, if you use <tt>Collections</tt> methods to remove a <tt>Track</tt> from an <tt>Album's tracks</tt> property, this breaks the link between the <tt>Album</tt> and <tt>Track</tt> but does <span class="docEmphasis">not</span> actually delete the <tt>Track</tt> record. Even if you later delete the entire <tt>Album</tt>, this <tt>Track</tt> will remain, because it wasn't linked to the <tt>Album</tt> at the time that it was deleted. Try some of these experiments by modifying <span class="docEmphasis">AlbumTest.java</span> appropriately and look at the resulting data in the tables!</p><hr style="height: 1px; color: gray; background-color: gray;"/></div></div></body>
</html>