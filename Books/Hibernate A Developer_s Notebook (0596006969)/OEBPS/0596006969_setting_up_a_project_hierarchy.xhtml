<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_setting_up_a_project_hierarchy"><a id="setting_up_a_project_hierarchy"/><h3 class="docSection1Title">1.3. Setting Up a Project Hierarchy</h3><p class="docText">Although we're going to start small, once we start designing data structures and building Java classes and database tables that represent them, along with all the configuration and control files to glue them together and make useful things happen, we're going to end up with a lot of files. So let's start out with a good organization from the beginning. As you'll see in this process, between the tools you've downloaded and their supporting libraries, there are already a significant number of files to organize.<a id="idx-CHP-1-0013"/><a id="idx-CHP-1-0014"/></p><a id="why_do_i_care-id002"/><h4 id="title-ID0E6BAE" class="docSection2Title">1.1.1. Why do I care?</h4><p class="docText">If you end up building something cool by following the examples in this book, and want to turn it into a real application, you'll be in good shape from the beginning. More to the point, if you set things up the way we describe here, the commands and instructions we give you throughout the examples will make sense and actually work. Many examples also build on one another throughout the book, so it's important to get on the right track from the beginning.</p><p class="docText">If you want to skip ahead to a later example, or just avoid typing some <a id="idx-CHP-1-0015"/>of the longer sample code and configuration files, you can download "finished" versions of the chapter examples from the book's web site. These downloads will all be organized as described here.</p><a id="how_do_i_do_that-id003"/><h4 id="title-ID0EMCAE" class="docSection2Title">1.1.2. How do I do that?</h4><p class="docText">Here's how:</p><div style="font-weight:bold"><ol class="docList" type="1"><li><div style="font-weight:normal"><p class="docList">Pick a location on your hard drive where you want to play with <a id="idx-CHP-1-0016"/>Hibernate, and create a new folder, which we'll refer to from now on as your <span class="docEmphasis">project directory</span>.<a id="idx-CHP-1-0017"/></p></div></li><li><div style="font-weight:normal"><p class="docList">Move into that directory, and create <a id="idx-CHP-1-0018"/>subdirectories called <span class="docEmphasis">src</span>, <span class="docEmphasis">lib</span>, and <span class="docEmphasis">data</span>. The <a id="idx-CHP-1-0019"/>hierarchy of Java source and related resources will be in the <span class="docEmphasis">src</span> directory. Our build process will compile it into a <span class="docEmphasis">classes</span> directory it creates, as well as copy any runtime resources there. The <span class="docEmphasis">data</span> directory is where we'll put the HSQLDB database, and any Data Definition Language (DDL) files we generate in order to populate it.</p><p class="docList">The lib directory is where we'll place third-party libraries we use in the project. For now, copy the HSQLDB and Hibernate JAR files into the <span class="docEmphasis">lib</span> directory.</p></div></li><li><div style="font-weight:normal"><p class="docList">If you haven't already done so, expand the HSQLDB distribution file you downloaded earlier in this chapter. You'll find <span class="docEmphasis">hsqldb.jar</span> in its <span class="docEmphasis">lib</span> directory; copy this to your own project <span class="docEmphasis">lib</span> directory (the <span class="docEmphasis">lib</span> directory you just created in step 2).</p></div></li><li><div style="font-weight:normal"><p class="docList">Similarly, locate the <span class="docEmphasis">lib</span> directory in the Hibernate directory you expanded in the previous section, and copy all of its contents into your own project <span class="docEmphasis">lib</span> directory (you'll notice that Hibernate relies on a lot of other libraries; conveniently, they're included in its binary distribution so you don't have to hunt them all down yourself).</p></div></li><li><div style="font-weight:normal"><p class="docList">Then copy Hibernate itself, in the form of the <span class="docEmphasis">hibernate2.jar</span> file found at the top level of the distribution, into your project <span class="docEmphasis">lib</span> directory.</p></div></li><li><div style="font-weight:normal"><p class="docList"><a id="idx-CHP-1-0020"/>Installing the <a id="idx-CHP-1-0021"/>Hibernate Extensions is very similar. Locate the <span class="docEmphasis">tools/lib</span> directory inside the Hibernate Extensions directory you expanded, and copy its contents into your own <span class="docEmphasis">lib</span> directory, so the extensions will be able to access the libraries they rely on.</p></div></li><li><div style="font-weight:normal"><p class="docList">Finally, copy the extensions themselves, which are in the file <span class="docEmphasis">hibernate-tools.jar</span> (found in the <span class="docEmphasis">tools</span> directory), into your <span class="docEmphasis">lib</span> directory.</p></div></li><li><div style="font-weight:normal"><p class="docList">The example classes we're going to create are all going to live in the <tt>com.oreilly.hh</tt><a id="these"/> (harnessing Hibernate) package, so create these <a id="idx-CHP-1-0022"/><a id="the"/>directories under the <span class="docEmphasis">src</span> directory. On Linux and Mac OS X, you can use:</p><pre>
							<b>mkdir -p src/com/oreilly/hh</b>
						</pre><br/>
</div></li></ol></div><blockquote><p class="docText"><span class="docEmphasis">There are lots of pieces to copy into place here; attention to detail will be rewarded. Luckily, you can reuse your lib directory in other Hibernate projects</span>.<a id="idx-CHP-1-0023"/></p></blockquote><p class="docText">At this point your project directory should be structured as shown in <a class="docLink" href="#initial_project_directory_contents">Figure 1-1</a>.</p><a id="initial_project_directory_contents"/><p/><div class="center"><h5 class="docFigureTitle">Figure 1-1. Initial project directory contents</h5><a id="I_mediaobject1_d1e673"/><p class="docText"><img src="Images/0596006969_setting_up_a_project_hierarchy_image01.png" alt="" width="266" height="212"/></p></div><br/><p class="docText">The <span class="docEmphasis">lib</span> directory is collapsed because it contains so much that the screen shot wouldn't fit otherwise. After following the above steps, using the release of Hibernate available at the time of this writing, it contains the following files:<a id="idx-CHP-1-0024"/></p><pre>
	README.txt, ant-1.5.3.jar, ant-optional-1.5.3.jar, apache.license.txt, c3p0-
	0.8.3.jar, c3p0.license.txt, cglib-2.0-rc2.jar, commons-collections-2.1.jar,
	commons-dbcp-1.1.jar, commons-lang-1.0.1.jar, commons-logging-1.0.3.jar,
	commons-pool-1.1.jar, concurrent-1.3.2.jar, connector.jar, connector.
	licence.txt, dom4j-1.4.jar, ehcache-0.6.jar, hibernate-tools.jar,
	hibernate2.jar, hsqldb.jar, jaas.jar, jaas.licence.txt, jboss-cache.jar,
	jboss-common.jar, jboss-jmx.jar, jboss-system.jar, jcs-1.0-dev.jar, jdbc2_0-
	stdext.jar, jdbc2_0-stdext.licence.txt, jdom.jar, jdom.license.txt, jgroups-
	2.2.jar, jta.jar, jta.licence.txt, junit-3.8.1.jar, log4j-1.2.8.jar, odmg-3.
	0.jar, oscache-2.0.jar, proxool-0.8.3.jar, swarmcache-1.0rc2.jar, xalan-2.4.
	0.jar, xerces-2.4.0.jar, xml-apis.jar.
</pre><br/>
<a id="a_quick_test"/><h4 id="title-ID0EMHAE" class="docSection2Title">1.3.1. A quick test</h4><p class="docText">Before we get into actually rousing Hibernate to do some useful work, it's worth checking that the other supporting pieces are in place and ready to use. Let's start out with the Ant configuration file we'll be using throughout this project, tell Ant where we've put the files we're using, and have it fire up the HSQLDB graphical database interface. This will be useful later when we want to look at the actual data that Hibernate has been creating for us, and it's reassuring right now as a sanity check that nothing is amiss and we're ready to move forward.</p><p class="docText">Fire up your favorite text editor and create a file named <i>build.xml</i> at the top level inside your project directory (the folder <span class="docEmphasis">ch01</span> in <a class="docLink" href="#initial_project_directory_contents">Figure 1-1</a>). Type the content shown in <a class="docLink" href="#ant_build_file">Example 1-1</a> into the file.</p><a id="ant_build_file"/><h5 id="title-ID0EAIAE" class="docExampleTitle">Example 1-1. Ant build file</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
1  &lt;?xml version="1.0"?&gt;
2  &lt;project name="Harnessing Hibernate: The Developer's Notebook"
3           default="db" basedir="."&gt;
4    &lt;!-- Set up properties containing important project directories --&gt;
5    &lt;property name="source.root" value="src"/&gt;
6    &lt;property name="class.root" value="classes"/&gt;
7    &lt;property name="lib.dir" value="lib"/&gt;
8    &lt;property name="data.dir" value="data"/&gt;
9
10    &lt;!-- Set up the class path for compilation and execution --&gt;
11    &lt;path id="project.class.path"&gt;
12        &lt;!-- Include our own classes, of course --&gt;
13        &lt;pathelement location="${class.root}"/&gt;
14        &lt;!-- Include jars in the project library directory --&gt;
15        &lt;fileset dir="${lib.dir}"&gt;
16          &lt;include name="**/*.jar"/&gt;
17        &lt;/fileset&gt;
18   &lt;/path&gt;
19
20   &lt;target name="db" description="Runs HSQLDB database management UI
21  against the database file--use when application is not running"&gt;
22       &lt;java classname="org.hsqldb.util.DatabaseManager"
23                fork="yes"&gt;
24             &lt;classpath refid="project.class.path"/&gt;
25             &lt;arg value="-driver"/&gt;
26             &lt;arg value="org.hsqldb.jdbcDriver"/&gt;
27             &lt;arg value="-url"/&gt;
28             &lt;arg value="jdbc:hsqldb:${data.dir}/music"/&gt;
29             &lt;arg value="-user"/&gt;
30             &lt;arg value="sa"/&gt;
31       &lt;/java&gt;
32   &lt;/target&gt;
33  &lt;/project&gt;
</pre><br/>
</td></tr></table><hr style="height: 1px; color: gray; background-color: gray;"/><p><span class="v2"><i><b>Tip:</b></i></span></p><p class="docText">Take care with punctuation in typing this, and pay special attention to self-closing XML tags (those which end in "/&gt;" rather than just "&gt;"). If you get it wrong, you'll be rewarded with parse errors when you run Ant. Again, you can download these files from the book's web site if you don't need the typing practice.</p><hr style="height: 1px; color: gray; background-color: gray;"/><p class="docText">If you haven't seen an <a id="idx-CHP-1-0025"/>Ant build file before, here's a whirlwind introduction to help orient you. The <a id="idx-CHP-1-0026"/>documentation at <a class="docLink" target="_blank" href="http://ant.apache.org/manual/index.html">http://ant.apache.org/manual/index.html</a> is quite good if you want a bit more detail. The first line is simply a declaration that the type of the file is XML. If you've worked with XML in other contexts, you're used to seeing this. If not, you'll see it again. (Ant doesn't currently require this, but most XML parsers do, so it's a good habit to develop.)</p><p class="docText">Ant's build files always contain a single <tt>project</tt> definition, which begins in this file on line 2. The <tt>default</tt> attribute tells Ant which <span class="docEmphasis">target</span> (defined below) to build if you don't specify any on the command line. And the <tt>basedir</tt> attribute determines the "directory relative to which all path calculations are done. We could have left this out since the default is to treat paths as being relative to the directory in which the <span class="docEmphasis">build.xml</span> is located, but it's a good habit to be explicit about fundamental settings.</p><p class="docText">The next bit, starting at line 4, defines four <span class="docEmphasis">properties</span> that we can use by name throughout the rest of the build file. Essentially, we're defining symbolic names for the important directories used for different aspects of the project. This isn't necessary (especially when the directories are named so simply), but it's another good practice. For one thing, it means that if you need to change where one of these directories is located, you only need to fix one place in the build file, rather than conducting an error-prone search-and-replace.</p><p class="docText">The class path section starting at line 10 serves a more obviously useful purpose. This feature alone is why I almost never start Java projects without setting up at least a simple Ant build for them. When you're using a lot of third-party libraries, which you're going to be doing for any serious project, there's a whole lot that needs to go into your class path, and you have to be sure to set it equivalently at compile time and runtime. Ant makes this very easy. We define a <span class="docEmphasis">path</span>, which is kind of like a property, but it knows how to parse and collect files and directories. Our path contains the <span class="docEmphasis">classes</span> directory, in which we're going to be compiling our Java source (this directory doesn't exist yet; we'll add a step to the build process that creates it in the next chapter), and it also contains all JAR files that can be found in our library directory. This is exactly what we need for compiling and running.</p><blockquote><p class="docText"><span class="docEmphasis">Ant's understanding and manipulation of Java paths and class hierarchies is a big plus. It's worth learning in some depth</span>.</p></blockquote><p class="docText">The syntax on line 13 looks like punctuation soup, but it can be broken down into pieces that make sense. Ant lets you use <span class="docEmphasis">substitution</span> to insert variable values into your rules. Where you see something like "${<tt>class. root</tt><a id="named"/>}" this means "look up the value of the variable named <tt>class.root</tt> and stick it here." So, given the definition of <tt>class.root</tt> on line 6, it's as if line 12 contained "<tt>&lt;pathelement location="classes"/&gt;"</tt>. So why do this? It lets you share a value throughout the file, so if you ever need to change it there's only one place to worry about. In large, complex projects this kind of organization and management is crucial.</p><p class="docText">Finally, with all this preamble out of the way we can define our first target at line 20. A target is just a series of <span class="docEmphasis">tasks</span> that need to be executed in order to accomplish a project goal. Typical targets do things like compile code, run tests, package things up for distribution, and the like. Tasks are chosen from a rich set of capabilities built-in to Ant, and third-party tools like Hibernate can extend Ant to provide their own useful tasks, as we'll see in the next chapter. Our first target, <tt>db</tt>, is going to run HSQLDB's graphical interface so we can look at our example database. We can accomplish that using Ant's built-in <tt>java</tt> task, which runs a Java virtual machine for us, with whatever starting class, arguments, and properties we'd like.</p><blockquote><p class="docText"><span class="docEmphasis">If your database GUI pops up and vanishes, double-check the "fork" attribute of your "java" task</span>.</p></blockquote><p class="docText">In this case, the class we want to invoke is <tt>org.hsqldb.util</tt>. <tt>DatabaseManager</tt>, found in <tt>hsqldb.jar</tt> in our project library directory. Setting the <tt>fork</tt> attribute to "yes" tells Ant to use a separate virtual machine, which isn't the default since it takes a little longer and isn't usually necessary. In this case it's important since we want the database manager GUI to stay around until we dismiss it, and this doesn't happen when it runs in Ant's own VM.</p><p class="docText">You can see how we're telling the <tt>java</tt> task about the class path we've set up above; this will be a common feature of our targets. Then we supply a bunch of arguments to the database manager, telling it to use the normal HSQLDB JDBC driver, where to find the database, and what username to use. We've specified a database called "music" in the <span class="docEmphasis">data</span> directory. That directory is currently empty, so HSQLDB will create the database the first time we use it. The user <tt>sa</tt> is the default "system administrator" user for new databases, and it's configured not to need a password <a id="idx-CHP-1-0027"/>initially. Obviously, if you plan to make this database available over the network (which HSQLDB is capable of doing) you'll want to set a password. We aren't doing any such fancy things, so we can leave it out for now.</p><p class="docText">Let's try it! Save the file and from a shell (command) prompt running in your top-level project directory (where you put <span class="docEmphasis">build.xml</span>) type the command:</p><pre>
					<b>ant db</b>
				</pre><br/>
<p class="docText">(or, since we've made <tt>db</tt> the default target, you can just type <span class="docEmphStrong">ant</span>). Once Ant starts running, if all goes well, you'll see output like this:</p><pre>
	Buildfile: build.xml

	db:
</pre><br/>
<p class="docText">A moment later you should see the HSQLDB graphic interface, which will look something like <a class="docLink" href="#the_hsqldb_database_manager_interface">Figure 1-2</a>. There's nothing in our database yet, so there's not much to see beyond whether the command worked at all. The tree view at the top left of the window is where the various tables and columns in our database can be explored. For now, just verify that the top reads "<tt>jdbc:hsqldb:data/music</tt>." You can explore the menus a bit if you like, but don't make any changes to the database. Once you're done, choose File → Exit. The window will close, and Ant will report:</p><pre>
	BUILD SUCCESSFUL
	Total time: 18 minutes 3 seconds
</pre><br/>
<a id="the_hsqldb_database_manager_interface"/><p/><div class="center"><h5 class="docFigureTitle">Figure 1-2. The HSQLDB database manager interface</h5><a id="I_mediaobject1_d1e861"/><p class="docText"><img src="Images/0596006969_setting_up_a_project_hierarchy_image02.png" alt="" width="396" height="150"/></p></div><br/><p class="docText">The "Total time" reflects how long you were running the database manager, so it will vary. At this point, if you look in the data directory, you'll find that HSQLDB has created some files to hold the database:</p><pre>
	music.properties music.script
</pre><br/>
<p class="docText">You can even look at the contents of these files. Unlike most database systems, HSQLDB stores its data in a human-readable format. The properties file contains some basic settings, and the data itself goes in the script file in the form of SQL statements. Right now all you'll find is the basic definitions that get entered by default, but as later examples start populating the database, you'll be able to see DDL and SQL statements that create the tables and data. This can be a useful debugging feature for basic sanity checks, even faster than firing up the graphical interface and running queries.</p><blockquote><p class="docText"><span class="docEmphasis">The fact that you can read HSQLDB's database files is weird but fun</span>.</p></blockquote><a id="what_just_happened-id001"/><h4 id="title-ID0EINAE" class="docSection2Title">1.3.2. What just happened?</h4><p class="docText">Well, to be honest, you jumped through a lot of hoops to find, download, expand, and organize a bunch of software. It was probably pretty tedious and exacting. But you're now in a great position to start working with Hibernate and, as you'll see in the next chapter, that means progress will start happening very quickly. You'll be able to see Java code written for you! Database schemas created out of thin air (or, at least, out of the same XML mapping table that produced the Java)! Real tables and data appearing in the HSQLDB manager interface! (Or, at least, genuine faux sample data….)</p><p class="docText">Sound exciting? Well, compared to what you've done so far anyway? Then let's dig in to awakening the power of Hibernate.</p><a id="why_didnt_it_work"/><h4 id="title-ID0EONAE" class="docSection2Title">1.3.3. Why didn't it work?</h4><p class="docText">If, on the other hand, you saw no database manager window appear, and instead were greeted by error messages, try to figure out if they're due to problems in the build file, problems in the way you've set up Ant or your project hierarchy, or something else. Double-check that all the pieces are arranged and installed as shown earlier, and consider downloading the sample code if you are having trouble with a version you typed in yourself.</p></div></div></body>
</html>