<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_custom_value_types"><a id="custom_value_types"/><h2 id="title-ID0E1WAG" class="docChapterTitle">7. Custom Value Types</h2><p class="docText">Hibernate supports a wealth <a id="idx-CHP-7-0236"/>of Java types, be they simple values or objects, as you can see by skimming <a class="docLink" href="0596006969_hibernate_types.xhtml#hibernate_types">Appendix A</a>. By setting up mapping specifications, you can persist even highly complex, nested object structures to arbitrary database tables and columns. With all this power and flexibility, you might wonder why you'd ever need to go beyond the built-in type support.</p><blockquote><p class="docText"><span class="docEmphasis">In this chapter</span>:</p><ul><li><p class="docList"><span class="docEmphasis">Defining a User Type</span></p></li><li><p class="docList"><span class="docEmphasis">Using a Custom Type Mapping</span></p></li><li><p class="docList"><span class="docEmphasis">Building a Composite User Type</span></p></li></ul></blockquote><p class="docText">One situation that might motivate you to customize Hibernate's type support is if you want to use a different SQL column type to store a particular Java type than Hibernate normally chooses. The reference documentation cites the example of persisting Java <tt>BigInteger</tt> values into <tt>VARCHAR</tt> columns, which might be necessary to accommodate a legacy database schema.</p><p class="docText">Another scenario that requires the ability to tweak the type system is when you have a single property value that needs to get split into more than one database column—maybe the <tt>Address</tt> object in your company's mandated reuse library stores ZIP+4 codes as a single string, but the database to which you're integrating contains a required five digit column and a separate nullable four digit column for the two components. Or maybe it's the other way around, and you need to separate a single database column into more than one property.</p><p class="docText">Luckily, in situations like this, Hibernate lets you take over the details of the persistence mapping so you can fit square pegs into round holes when you really need to.</p><blockquote><p class="docText"><span class="docEmphasis">Continuing in the spirit of making simple things easy and complex things possible…</span></p></blockquote><p class="docText">You might also want to build a custom value type even in some cases where it's not strictly necessary. If you've got a composite type that is used in many places throughout your application (a vector, complex number, address, or the like), you can certainly map each of these occurrences as components, but it might be worth encapsulating the details of the mapping in a shared, reusable Java class rather than propagating the details throughout each of the mapping documents. That way, if the details of the mapping ever need to change for any reason, you've only got one class to fix rather than many individual component mappings to hunt down and adjust.</p></div></div></body>
</html>