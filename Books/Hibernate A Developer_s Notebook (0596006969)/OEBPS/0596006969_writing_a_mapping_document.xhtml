<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}#sbo-rt-content *{word-wrap:break-word!important;word-break:break-word!important;}#sbo-rt-content table,#sbo-rt-content pre{overflow-x:unset!important;overflow:unset!important;overflow-y:unset!important;white-space:pre-wrap!important;}</style></head>
<body><div id="sbo-rt-content"><div id="id0596006969_writing_a_mapping_document"><a id="writing_a_mapping_document"/><h3 class="docSection1Title">2.1. Writing a Mapping Document</h3><p class="docText">Hibernate uses an XML document to track the mapping between Java classes and relational database tables. This <span class="docEmphasis">mapping document</span> is designed to be readable and hand-editable. You can also start by using graphical <a id="idx-CHP-2-0031"/>CASE tools (like Together, Rose, or Poseidon) to build UML dia grams representing your data model, and feed these into <a id="idx-CHP-2-0032"/>AndroMDA (<a class="docLink" target="_blank" href="http://www.andromda.org/">http://www.andromda.org/</a><a id="idx-CHP-2-0033"/>), turning them into Hibernate mappings.</p><blockquote><p class="docText"><span class="docEmphasis">Don't forget that Hibernate and its extensions let you work in other ways, starting with classes or data if you've got them</span>.</p></blockquote><p class="docText">We'll write one by hand, showing it's quite practical.</p><p class="docText">We're going to start by writing a mapping document for <span class="docEmphasis">tracks</span>, pieces of music that can be listened to individually or as part of an album or play list. To begin with, we'll keep track of the track's title, the path to the file containing the actual music, its playing time, the date on which it was added to the database, and the volume at which it should be played (in case the default volume isn't appropriate because it was recorded at a very different level than other music in the database).</p><a id="why_do_i_care-id003"/><h4 id="title-ID0EDHAE" class="docSection2Title">2.1.1. Why do I care?</h4><p class="docText">You might not have any need for a new system to keep track of your music, but the concepts and process involved in setting up this mapping will translate to the projects you actually want to tackle.</p><a id="how_do_i_do_that-id004"/><h4 id="title-ID0EIHAE" class="docSection2Title">2.1.2. How do I do that?</h4><p class="docText">Fire up your favorite text editor, and create the file <i>Track.hbm.xml</i> in the <span class="docEmphasis">src/com/oreilly/hh</span> directory you set up in the previous chapter. (If you skipped that chapter, you'll need to go back and follow it, because this example relies on the project structure and tools we set up there.) Type in the <a id="idx-CHP-2-0034"/>mapping document as shown in <a class="docLink" href="#the_mapping_document_for_tracks_trackhbm">Example 2-1</a>. Or, if you'd rather avoid all that typing, download the code examples from this book's website, and find the mapping file in the directory for <a class="docLink" href="0596006969_introduction_to_mapping.xhtml#introduction_to_mapping">Chapter 2</a>.</p><a id="the_mapping_document_for_tracks_trackhbm"/><h5 id="title-ID0ECIAE" class="docExampleTitle">Example 2-1. The mapping document for tracks, Track.hbm.xml</h5><table cellspacing="0" width="*" border="1" cellpadding="5"><tr><td><pre>
 1  &lt;?xml version="1.0"?&gt;
 2  &lt;!DOCTYPE hibernate-mapping 
 3            PUBLIC "-//Hibernate/Hibernate Mapping DTD 2.0//EN"
 4            "http://hibernate.sourceforge.net/hibernate-mapping-2.0.dtd"&gt;
 5  &lt;hibernate-mapping&gt;
 6
 7    &lt;class name="com.oreilly.hh.Track" table="TRACK"&gt; 
 8      &lt;meta attribute="class-description"&gt;
 9        Represents a single playable track in the <a id="idx-CHP-2-0035"/>music database.
10        @author Jim Elliott (with help from Hibernate) 
11      &lt;/meta&gt;
12
13      &lt;id name="id" type="int" column="TRACK_ID"&gt; 
14        &lt;meta attribute="scope-set"&gt;protected&lt;/meta&gt; 
15        &lt;generator class="native"/&gt; 
16      &lt;/id&gt; 
17
18      &lt;property name="title" type="string" not-null="true"/&gt;
19
20      &lt;property name="filePath" type="string" not-null="true"/&gt;
21
22      &lt;property name="playTime" type="time"&gt;
23        &lt;meta attribute="field-description"&gt;Playing time&lt;/meta&gt;
24      &lt;/property&gt;
25
26      &lt;property name="added" type="date"&gt; 
27        &lt;meta attribute="field-description"&gt;When the track was created&lt;/meta&gt;
28      &lt;/property&gt;
29
30      &lt;property name="volume" type="short"&gt;
31        &lt;meta attribute="field-description"&gt;How loud to play the track&lt;/meta&gt;
32      &lt;/property&gt;
33
34    &lt;/class&gt;
35  &lt;/hibernate-mapping&gt;
</pre><br/>
</td></tr></table><p class="docText">The first four lines are a required preamble to make this a <a id="idx-CHP-2-0036"/>valid XML document and announce that it conforms to the document type definition used by Hibernate for mappings. The actual mappings are inside the <tt>hibernate-mapping</tt> tag. Starting at line 7 we're defining a <a id="idx-CHP-2-0037"/>mapping for a single <a id="idx-CHP-2-0038"/>class, <tt>com.oreilly.hh.Track</tt>, and the name and package of this class are related to the name and location of the file we've created. This relationship isn't necessary; you can define mappings for any number of classes in a single mapping document, and name it and locate it anywhere you want, as long as you tell Hibernate how to find it. The advantage of following the convention of <a id="idx-CHP-2-0039"/>naming the mapping file after the class it maps, and placing it in the same place on the class path as that class, is that this allows Hibernate to automatically locate the mapping when you want to work with the class. This simplifies the configuration and use of Hibernate.<a id="idx-CHP-2-0040"/></p><p class="docText">In the opening of the <tt>class</tt> tag on line 7, we have also specified that this class is stored in a database table named <tt>TRACK</tt>. The next tag, a <tt>meta</tt> tag (lines 8–11), doesn't directly affect the mapping. Instead, it <a id="idx-CHP-2-0041"/>provides additional information that can be used by different tools. In this case, by specifying an <tt>attribute</tt> value of "class-description," we are telling the Java code generation tool the JavaDoc text we want associated with the <tt>Track</tt> class. This is entirely optional, and you'll see the result of including it in the upcoming section, "Generating Some Class."</p><hr style="height: 1px; color: gray; background-color: gray;"/><p><span class="v2"><i><b>Tip:</b></i></span></p><p class="docText">Although databases vary in terms of whether they keep track of the capitalization of table and column names, this book will use the convention of referring to these database entities in all-caps, to help clarify when something being discussed is a database column or table, as opposed to a persistent Java class or property.</p><hr style="height: 1px; color: gray; background-color: gray;"/><p class="docText">The remainder of the mapping sets up the pieces of information we want to keep track of, as properties in the class and their associated columns in the database table. Even though we didn't mention it in the introduction to this example, each track is going to need an <span class="docEmphasis">id</span>. Following database best practices, we'll use a meaningless <span class="docEmphasis">surrogate key</span> (a value with no semantic meaning, serving only to identify a specific database row). In Hibernate, the key/id mapping is set up using an <tt>id</tt> tag (starting at line 13). We're choosing to use an <tt>int</tt> to store our <tt>id</tt> in the database column <tt>TRACK_ID</tt>, which will correspond to the property <tt>id</tt> in our <tt>Track</tt> object. This mapping contains another <tt>meta</tt> tag to communicate with the Java code generator, telling it that the <tt>set</tt> method for the <tt>id</tt> property should be protected—there's no need for application code to go changing track IDs.</p><p class="docText">The <tt>generator</tt> tag on line 15 configures how Hibernate creates <tt>id</tt> values for new instances. (Note that it relates to normal O/R <a id="idx-CHP-2-0042"/>mapping operation, <span class="docEmphasis">not</span> to the Java code <tt>generator</tt>, which is often not even used; <tt>generator</tt> is more fundamental than the optional <tt>meta</tt> tags.) There are a number of different ID generation strategies to choose from, and you can even write your own. In this case, we're telling Hibernate to use whatever is most natural for the underlying database (we'll see later on how it learns what database we're using). In the case of HSQLDB, an identity column is used.<a id="idx-CHP-2-0043"/></p><blockquote><p class="docText"><span class="docEmphasis">You may be thinking there's a lot of dense information in this file. That's true, and as you'll see, it can be used to create a bunch of useful project resources</span>.</p></blockquote><p class="docText">After the id, we just enumerate the various track properties we care about. The <tt>title</tt> (line 18) is a string, and it cannot be null. The <tt>filePath</tt> (line 20) has the same characteristics, while the remainder are allowed to be null: <tt>playTime</tt> (line 22) is a <tt>time</tt>, <tt>added</tt> (line 26) is a <tt>date</tt>, and <tt>volume</tt> (line 30) is a <tt>short</tt>. These last three properties use a new kind of <tt>meta</tt> attribute, "field-description," which specifies JavaDoc text for the individual properties, with some limitations in the current code generator.</p><a id="what_just_happened-id002"/><h4 id="title-ID0EKNAE" class="docSection2Title">2.1.3. What just happened?</h4><p class="docText">We took the abstract description of the information about music tracks that we wanted to represent in our Java code and database, and turned it into a rigorous specification in the format that Hibernate can read. Hopefully you'll agree that it's a pretty compact and readable representation of the information. Next we'll look at what Hibernate can actually do with it.</p><a id="what_abouthellip-id002"/><h4 id="title-ID0EPNAE" class="docSection2Title">2.1.4. What about…</h4><p class="docText">…Other data types, including nested classes and enumerations? Relationships between tables? Indices? Class hierarchies and polymorphism?Tables that contain rows we need to ignore? Hibernate can handle all these things, and we'll cover most of them in later examples. <a class="docLink" href="0596006969_hibernate_types.xhtml#hibernate_types">Appendix A</a> lists the basic types that Hibernate supports "out of the box."</p></div></div></body>
</html>