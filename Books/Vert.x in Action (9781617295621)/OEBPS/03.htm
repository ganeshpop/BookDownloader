<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style02.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content" class="calibre"><div class="tocheadb">
    <h1 class="tochead" id="heading_id_2"><a id="pgfId-998407"/><a id="pgfId-1018146"/>3 Event bus: The backbone of a Vert.x application</h1>
  </div>

  <p class="co-summary-head"><a id="pgfId-1011800"/>This chapter covers</p>

  <ul class="calibre8">
    <li class="co-summary-bullet"><a class="calibre9" id="pgfId-1011837"/>What the event bus is</li>

    <li class="co-summary-bullet"><a class="calibre9" id="pgfId-1011851"/>How to have point-to-point, request-reply, and publish/subscribe communications over the event bus</li>

    <li class="co-summary-bullet"><a class="calibre9" id="pgfId-1011861"/>The distributed event bus for verticle-to-verticle communication across the network</li>
  </ul>

  <p class="body"><a id="pgfId-1011871"/>The previous chapter introduced <i class="fm-italics">verticles</i>. A Vert.x application is made up <a id="marker-1011882"/>of one or more verticles, and each verticle forms a unit for processing asynchronous events. It is common to specialize verticles by functional and technical concerns, such as having one verticle for exposing an HTTP API and another for dealing with a data store. This design also encourages the deployment of several instances of a given verticle for scalability purposes.</p>

  <p class="body"><a id="pgfId-1011908"/>What we have <i class="fm-italics">not</i> covered yet is how verticles can communicate with each other. For example, an HTTP API verticle needs to <i class="fm-italics">talk</i> to the data store verticle if the larger Vert.x application is to do anything useful.</p>

  <p class="body"><a id="pgfId-1011917"/>Connecting verticles and making sure they can cooperate is the role of the <i class="fm-italics">event bus</i>. This is important when building reactive applications--the event bus offers a way to transparently distribute event-processing work both inside a process and across several nodes over the network.</p>

  <h2 class="fm-head" id="heading_id_3"><a id="pgfId-1011932"/>3.1 What is the event bus?</h2>

  <p class="body"><a id="pgfId-1011978"/><a id="marker-1011943"/>The event bus is a means for sending and receiving messages in an asynchronous fashion. Messages are sent to and retrieved from <i class="fm-italics">destinations</i>. A destination <a id="marker-1011957"/>is simply a free-form string, such as <code class="fm-code-in-text">incoming.purchase.orders</code> or <code class="fm-code-in-text">incoming-purchase-orders</code>, although the former format with dots is preferred.</p>

  <p class="body"><a id="pgfId-1011987"/>Messages have a body, optional headers for storing metadata, and an expiration timestamp after which they will be discarded if they haven’t been processed yet.</p>

  <p class="body"><a id="pgfId-1011993"/>Message bodies are commonly encoded using the Vert.x JSON representation. The advantage of using JSON is that it is a serialization format that can be easily transported over the network, and all programming languages understand it. It is also possible to use Java primitive and string types, especially as JVM languages that may be used for writing verticles have direct bindings for them. Last but not least, it is possible to register custom encoder/decoders (codecs) to support more specialized forms of message body serialization. For instance, you could write a codec for converting Java objects to a binary encoding of your own. It is rarely useful to do so, however, and JSON and string data cover most Vert.x applications’ needs.</p>

  <p class="body"><a id="pgfId-1011999"/>The event bus allows for decoupling between verticles. There is no need for one verticle to access another verticle class--all that is needed is to agree on destination names and data representation. Another benefit is that since Vert.x is polyglot, the event bus allows verticles written in different languages to communicate with each other without requiring any complex language interoperability layer, whether for communications inside the same JVM process or across the network.</p>

  <p class="body"><a id="pgfId-1012005"/>An interesting property of the event bus is that it can be extended outside of the application process. You will see in this chapter that the event bus also works across distributed members of a cluster. Later in this book you will see how to extend the event bus to embedded or external message brokers, to remote clients, and also to JavaScript applications running in a web browser.</p>

  <p class="body"><a id="pgfId-1012011"/>Communications over the event bus follow three patterns:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1012017"/>Point-to-point messaging</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012031"/>Request-reply messaging</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1012041"/>Publish/subscribe messaging</p>
    </li>
  </ul>

  <h3 class="fm-head1" id="heading_id_4"><a id="pgfId-1012051"/>3.1.1 Is the event bus just another message broker?</h3>

  <p class="body"><a id="pgfId-1012061"/><a id="marker-1012062"/>Readers familiar with message-oriented middleware will have spotted the obvious resemblance between the event bus and a message broker. After all, the event bus exhibits familiar messaging patterns, such as the publish/subscribe pattern, which is popular for integrating distributed and heterogeneous applications.</p>

  <p class="body"><a id="pgfId-1012092"/>The short answer is that no, the Vert.x event bus is not an alternative to Apache ActiveMQ, RabbitMQ, ZeroMQ, or Apache Kafka. The longer explanation is that it is an <i class="fm-italics">event</i> bus for verticle-to-verticle communications inside an <a id="marker-1012081"/>application, not a <i class="fm-italics">message</i> bus for application-to-application communications. As you will see later in this book, Vert.x integrates with message brokers, but the event bus is no replacement for this type of middleware. Specifically, the event bus does not do the following:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1012101"/>Support message acknowledgments</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012115"/>Support message priorities</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012125"/>Support message durability to recover from crashes</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012135"/>Provide routing rules</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1012145"/>Provide transformation rules (schema adaptation, scatter/gather, etc.)</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1012155"/>The event bus simply carries <i class="fm-italics">volatile</i> events that are being <a id="marker-1012166"/>processed asynchronously by verticles.</p>

  <p class="body"><a id="pgfId-1012176"/>Not all events are created equal, and while some may be lost, some may not. In our quest for writing <i class="fm-italics">reactive applications</i>, you will see where to use data replication or message brokers such as Apache Kafka in combination with the event bus.<a href="#pgfId-1012188">1</a></p>

  <p class="body"><a id="pgfId-1012210"/>The event bus is a simple and <i class="fm-italics">fast</i> event conveyor, and we can take advantage of it for most verticle-to-verticle interactions, while turning to more costly middleware for events that cannot be lost.</p>

  <p class="fm-callout"><a id="pgfId-1012235"/><span class="fm-callout-head">Tip</span> Readers familiar with messaging patterns may want to skim the next three subsections, or even skip them. <a id="marker-1012237"/></p>

  <h3 class="fm-head1" id="heading_id_5"><a id="pgfId-1012244"/>3.1.2 Point-to-point messaging</h3>

  <p class="body"><a id="pgfId-1012277"/><a id="marker-1012255"/><a id="marker-1012257"/>Messages are sent by producers to destinations, such as <code class="fm-code-in-text">a.b.c</code> in figure 3.1. Destination names are free-form strings, but the convention in the Vert.x community is to use separating dots. For example, we could use <code class="fm-code-in-text">datastore.new-purchase-orders</code> to send new purchase <a id="marker-1012282"/>orders to be stored in a database.</p>

  <p class="body"><a id="pgfId-1012342"/>With point-to-point messaging, one of the possibly multiple consumers picks a message and processes it. Figure 3.1 shows this with messages <code class="fm-code-in-text">M1</code>, <code class="fm-code-in-text">M2</code>, and <code class="fm-code-in-text">M3</code>.</p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F01_Ponge.png" width="995" height="327"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1026925"/>Figure 3.1 Point-to-point messaging over the event bus</p>

  <p class="body"><a id="pgfId-1012377"/>Messages are distributed in a round-robin fashion among the consumers, so they split message processing in equal proportions. This is why in figure 3.1 the first consumer processes <code class="fm-code-in-text">M1</code> and <code class="fm-code-in-text">M3</code>, while the second consumer processes <code class="fm-code-in-text">M2</code>. Note that there is no fairness mechanism to distribute fewer messages to an overloaded consumer. <a id="marker-1012382"/><a id="marker-1012385"/></p>

  <h3 class="fm-head1" id="heading_id_6"><a id="pgfId-1012391"/>3.1.3 Request-reply messaging</h3>

  <p class="body"><a id="pgfId-1012414"/><a id="marker-1012402"/><a id="marker-1012404"/>In Vert.x, the request-reply messaging communication pattern is a variation on point-to-point messaging. When a message is sent in point-to-point messaging, it is possible to register a <i class="fm-italics">reply</i> handler. When you <a id="marker-1012419"/>do, the event bus generates a temporary destination name dedicated solely to communications between the request message producer that is expecting a reply, and the consumer that will eventually receive and process the message.</p>

  <p class="body"><a id="pgfId-1012429"/>This messaging pattern works well for mimicking remote procedure calls, but with the response being sent in an asynchronous fashion, so there is no need to keep waiting until it comes back. For example, an HTTP API verticle can send a request to a data store verticle to fetch some data, and the data store verticle eventually returns a reply message.</p>

  <p class="body"><a id="pgfId-1012448"/>This pattern is illustrated in figure 3.2. When a message expects a reply, a reply destination is generated by the event bus and attached to the message before it reaches a consumer. You can inspect the reply destination name through the event-bus message API if you want, but you will rarely need to know the destination, since you will <a id="marker-1012437"/>simply call a <code class="fm-code-in-text">reply</code> method on the message object. Of course, a message consumer needs to be programmed to provide a reply when this pattern is being used. <a id="marker-1012453"/><a id="marker-1012456"/></p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F02_Ponge.png" width="935" height="218"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1026967"/>Figure 3.2 Request-reply messaging over the event bus</p>

  <h3 class="fm-head1" id="heading_id_7"><a id="pgfId-1012472"/>3.1.4 Publish/subscribe messaging</h3>

  <p class="body"><a id="pgfId-1012529"/><a id="marker-1012497"/><a id="marker-1012499"/>In publish/subscribe communications, there is even more decoupling between producers and consumers. When a message is sent to a destination, all subscribers receive it, as illustrated by figure 3.3. Messages <code class="fm-code-in-text">M1</code>, <code class="fm-code-in-text">M2</code>, and <code class="fm-code-in-text">M3</code> are each sent by a different producer, and all subscribers receive the messages, unlike in the case of point-to-point messaging (see figure 3.1). It is not possible to specify reply handlers for publish/subscribe communications on the event bus.</p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F03_Ponge.png" width="901" height="293"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027009"/>Figure 3.3 Publish/subscribe messaging over the event bus</p>

  <p class="body"><a id="pgfId-1012548"/>Publish/subscribe is useful when you are not sure how many verticles and handlers will be interested in a particular event. If you need message consumers to get back to the entity that sent the event, go for request-reply. Otherwise, opting for point-to-point versus publish/subscribe is a matter of functional requirements, mostly whether all consumers should process an event or just one consumer should. <a id="marker-1012564"/><a id="marker-1012567"/><a id="marker-1012569"/></p>

  <h2 class="fm-head" id="heading_id_8"><a id="pgfId-1012575"/>3.2 The event bus in an example</h2>

  <p class="body"><a id="pgfId-1012585"/><a id="marker-1012586"/>Let’s put the event bus to use and see how we can communicate between independent verticles. The example that we’ll use involves several temperature sensors. Of course, we won’t use any hardware. Instead we’ll let temperatures evolve using pseudo-random numbers. We will also expose a simple web interface where temperatures and their average will be updated live.</p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F04_Ponge.png" width="984" height="542"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027054"/>Figure 3.4 Screenshot of the web interface</p>

  <p class="body"><a id="pgfId-1012613"/>A screenshot of the web interface is shown in figure 3.4. It displays the temperatures from four sensors and keeps their average up to date. The communication between the web interface and the server will happen <a id="marker-1012602"/>using <i class="fm-italics">server-sent events</i>, a simple yet effective protocol supported by most web browsers.<a href="#pgfId-1012619">2</a></p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F05_Ponge.png" width="998" height="706"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027099"/>Figure 3.5 Overview of the example architecture</p>

  <p class="body"><a id="pgfId-1012672"/>Figure 3.5 gives an overview of the application architecture. The figure shows two concurrent event communications annotated with ordering sequences <code class="fm-code-in-text">[1,</code> <code class="fm-code-in-text">2,</code> <code class="fm-code-in-text">3]</code> (a temperature update is being sent) and <code class="fm-code-in-text">[a,</code> <code class="fm-code-in-text">b,</code> <code class="fm-code-in-text">c,</code> <code class="fm-code-in-text">d]</code> (a temperature average computation is being requested).</p>

  <p class="body"><a id="pgfId-1012691"/>The application is structured around four verticles:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1012739"/><code class="fm-code-in-text">HeatSensor</code> generates temperature <a class="calibre9" id="marker-1012728"/>measures at non-fixed rates and publishes them to subscribers to the <code class="fm-code-in-text">sensor.updates</code> destination. Each verticle <a class="calibre9" id="marker-1012744"/>has a unique sensor identifier.</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012754"/><code class="fm-code-in-text">Listener</code> monitors new temperature measures and logs them using SLF4J.</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1012795"/><code class="fm-code-in-text">SensorData</code> keeps a record of the <a class="calibre9" id="marker-1012784"/>latest observed values for each sensor. It also supports request-response communications: sending a message to <code class="fm-code-in-text">sensor .average</code> triggers a computation of the average based on the latest data, and the result is sent back as a response.</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1012804"/><code class="fm-code-in-text">HttpServer</code> exposes the HTTP server <a class="calibre9" id="marker-1012817"/>and serves the web interface. It pushes new values to its clients whenever a new temperature measurement has been observed, and it periodically asks for the current average and updates all the connected clients.</p>
    </li>
  </ul>

  <h3 class="fm-head1" id="heading_id_9"><a id="pgfId-1012827"/>3.2.1 Heat sensor verticle</h3>

  <p class="body"><a id="pgfId-1012856"/><a id="marker-1012838"/><a id="marker-1012840"/>The following listing shows the implementation <a id="marker-1012845"/>of the <code class="fm-code-in-text">HeatSensor</code> verticle class.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1012916"/>Listing 3.1 <code class="fm-code-in-listingcaption">Heatsensor</code> verticle implementation</p>
  <pre class="programlisting">public class HeatSensor extends AbstractVerticle {
  private final Random random = new Random();
  private final String sensorId = UUID.randomUUID().toString();   <span class="fm-combinumeral">❶</span>
  private double temperature = 21.0;

  @Override
  public void start() {
    scheduleNextUpdate();
  }

  private void scheduleNextUpdate() {
    vertx.setTimer(random.nextInt(5000) + 1000, this::update);    <span class="fm-combinumeral">❷</span>
  }

  private void update(long timerId) {
    temperature = temperature + (delta() / 10);
    JsonObject payload = new JsonObject()
      .put("id", sensorId)
      .put("temp", temperature);
    vertx.eventBus().publish("sensor.updates", payload);          <span class="fm-combinumeral">❸</span>
    scheduleNextUpdate();                                         <span class="fm-combinumeral">❹</span>
  }

  private double delta() {                                        <span class="fm-combinumeral">❺</span>
    if (random.nextInt() &gt; 0) {
      return random.nextGaussian();
    } else {
      return -random.nextGaussian();
    }
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025998"/><span class="fm-combinumeral">❶</span> The sensor identifier is generated using a UUID.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1026019"/><span class="fm-combinumeral">❷</span> Updates are scheduled with a random delay between one and six seconds.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1026036"/><span class="fm-combinumeral">❸</span> publish sends a message to subscribers.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1026053"/><span class="fm-combinumeral">❹</span> We schedule the next update.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1026070"/><span class="fm-combinumeral">❺</span> This computes a random positive or negative value to slightly modify the current temperature.</p>

  <p class="body"><a id="pgfId-1013245"/>The <code class="fm-code-in-text">HeatSensor</code> verticle class does not use any realistic temperature model but instead uses random increments or decrements. Hence, if you run it long enough, it may report absurd values, but this is not very important in our journey through reactive applications.</p>

  <p class="body"><a id="pgfId-1013308"/>The event bus is accessed through the <code class="fm-code-in-text">Vertx</code> context and the <code class="fm-code-in-text">eventBus()</code> method. Since this verticle <a id="marker-1013281"/>does not know what the published values will be used <a id="marker-1013287"/>for, we use the <code class="fm-code-in-text">publish</code> method to send them to subscribers on the <code class="fm-code-in-text">sensor.updates</code> destination. We also use JSON to encode data, which is idiomatic with Vert.x.</p>

  <p class="body"><a id="pgfId-1013317"/>Let’s now look at a verticle that consumes temperature updates. <a id="marker-1013319"/><a id="marker-1013322"/></p>

  <h3 class="fm-head1" id="heading_id_10"><a id="pgfId-1013328"/>3.2.2 Listener verticle</h3>

  <p class="body"><a id="pgfId-1013357"/><a id="marker-1013339"/><a id="marker-1013341"/>The following listing shows the implementation <a id="marker-1013346"/>of the <code class="fm-code-in-text">Listener</code> verticle class.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1013417"/>Listing 3.2 <code class="fm-code-in-listingcaption">Listener</code> verticle implementation</p>
  <pre class="programlisting">public class Listener extends AbstractVerticle {
  private final Logger logger = LoggerFactory.getLogger(Listener.class);
  private final DecimalFormat format = new DecimalFormat("#.##");        <span class="fm-combinumeral">❶</span>

  @Override
  public void start() {
    EventBus bus = vertx.eventBus();
    bus.&lt;JsonObject&gt;consumer("sensor.updates", msg -&gt; {                  <span class="fm-combinumeral">❷</span>
      JsonObject body = msg.body();                                      <span class="fm-combinumeral">❸</span>
      String id = body.getString("id");
      String temperature = format.format(body.getDouble("temp"));
      logger.info("{} reports a temperature ~{}C", id, temp);            <span class="fm-combinumeral">❹</span>
    });
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025714"/><span class="fm-combinumeral">❶</span> We don’t need the full double value, so we format all temperatures to two-decimal string representations.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025735"/><span class="fm-combinumeral">❷</span> The consumer method allows subscribing to messages, and a callback handles all event-bus messages.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025752"/><span class="fm-combinumeral">❸</span> The message payload is in the body.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025769"/><span class="fm-combinumeral">❹</span> We simply log.</p>

  <p class="body"><a id="pgfId-1013673"/>The purpose of the <code class="fm-code-in-text">Listener</code> verticle class is to log all temperature measures, so all it does is listen to messages received on the <code class="fm-code-in-text">sensor.updates</code> destination. Since the emitter <a id="marker-1025846"/>in the <code class="fm-code-in-text">HeatSensor</code> class uses a publish/subscribe pattern, <code class="fm-code-in-text">Listener</code> is not the only verticle that can receive the messages.</p>

  <p class="body"><a id="pgfId-1013682"/>We did not take advantage of message headers in this example, but it is possible to use them for any metadata that does not belong to the message body. A common header is that of an “action,” to help receivers know what the message is about. For instance, given a <code class="fm-code-in-text">database.operations</code> destination, we could <a id="marker-1013693"/>use an action header to specify whether we intend to query the database, update an entry, store a new entry, or delete a previously stored one.</p>

  <p class="body"><a id="pgfId-1013703"/>Let’s now look at another verticle that consumes temperature updates. <a id="marker-1013705"/><a id="marker-1013708"/></p>

  <h3 class="fm-head1" id="heading_id_11"><a id="pgfId-1013714"/>3.2.3 Sensor data verticle</h3>

  <p class="body"><a id="pgfId-1013743"/><a id="marker-1013725"/><a id="marker-1013727"/>The following listing shows the implementation <a id="marker-1013732"/>of the <code class="fm-code-in-text">SensorData</code> verticle class.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1013803"/>Listing 3.3 <code class="fm-code-in-listingcaption">Sensordata</code> verticle implementation</p>
  <pre class="programlisting">public class SensorData extends AbstractVerticle {
  private final HashMap&lt;String, Double&gt; lastValues = new HashMap&lt;&gt;();   <span class="fm-combinumeral">❶</span>

  @Override
  public void start() {                                                 <span class="fm-combinumeral">❷</span>
    EventBus bus = vertx.eventBus();
    bus.consumer("sensor.updates", this::update);
    bus.consumer("sensor.average", this::average);
  }

  private void update(Message&lt;JsonObject&gt; message) {                    <span class="fm-combinumeral">❸</span>
    JsonObject json = message.body();
    lastValues.put(json.getString("id"), json.getDouble("temp"));
  }

  private void average(Message&lt;JsonObject&gt; message) {                   <span class="fm-combinumeral">❹</span>
    double avg = lastValues.values().stream()
      .collect(Collectors.averagingDouble(Double::doubleValue));
    JsonObject json = new JsonObject().put("average", avg);
    message.reply(json);                                                <span class="fm-combinumeral">❺</span>
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025332"/><span class="fm-combinumeral">❶</span> We store the latest measurement of each sensor by its unique identifier.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025353"/><span class="fm-combinumeral">❷</span> The start method only declares two event-bus destination handlers.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025370"/><span class="fm-combinumeral">❸</span> When a new measurement is being received, we extract the data from the JSON body.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025387"/><span class="fm-combinumeral">❹</span> The incoming message for average requests is not used, so it can just contain an empty JSON document.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025404"/><span class="fm-combinumeral">❺</span> The reply method is used to reply to a message.</p>

  <p class="body"><a id="pgfId-1014095"/>The <code class="fm-code-in-text">SensorData</code> class has two event-bus handlers: one for sensor updates and one for average temperature computation requests. In one case, it updates entries in a <code class="fm-code-in-text">HashMap</code>, and in the other case, it computes the average and responds to the message sender.</p>

  <p class="body"><a id="pgfId-1014104"/>The next verticle is the HTTP server. <a id="marker-1014106"/><a id="marker-1014109"/></p>

  <h3 class="fm-head1" id="heading_id_12"><a id="pgfId-1014115"/>3.2.4 HTTP server verticle</h3>

  <p class="body"><a id="pgfId-1014138"/><a id="marker-1014126"/><a id="marker-1014128"/>The HTTP server is interesting as it requests temperature averages from the <code class="fm-code-in-text">SensorData</code> verticle via the event bus, and it implements the server-sent events protocol to consume temperature updates.</p>

  <p class="body"><a id="pgfId-1014147"/>Let’s start with the backbone of this verticle implementation.</p>

  <p class="fm-head2"><a id="pgfId-1014153"/>Server implementation</p>

  <p class="body"><a id="pgfId-1014163"/><a id="marker-1014164"/>The following listing shows a classical example of starting an HTTP server and declaring a request handler.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1014223"/>Listing 3.4 Prologue of the HTTP server verticle implementation</p>
  <pre class="programlisting">public class HttpServer extends AbstractVerticle {
  @Override
  public void start() {
    vertx.createHttpServer()
      .requestHandler(this::handler)
      .listen(config().getInteger("port", 8080));        <span class="fm-combinumeral">❶</span>
  }

  private void handler(HttpServerRequest request) {
    if ("/".equals(request.path())) {
      request.response().sendFile("index.html");         <span class="fm-combinumeral">❷</span>
    } else if ("/sse".equals(request.path())) {
      sse(request);                                      <span class="fm-combinumeral">❸</span>
    } else {
      request.response().setStatusCode(404);             <span class="fm-combinumeral">❹</span>
    }
  }
// (...)
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025071"/><span class="fm-combinumeral">❶</span> The HTTP server port is configured with 8080 as the default value.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025092"/><span class="fm-combinumeral">❷</span> The sendFile method allows the content of any local file to be streamed to the client. This closes the connection automatically.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025109"/><span class="fm-combinumeral">❸</span> Server-sent events will use the /sse resource, and we provide a method for handling these requests.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1025126"/><span class="fm-combinumeral">❹</span> Anything else triggers an HTTP 404 (not found) response.</p>

  <p class="body"><a id="pgfId-1014470"/>The handler deals with three cases:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1014476"/>Serving the web application to browsers</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1014490"/>Providing a resource for server-sent events</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1014500"/>Responding with 404 errors for any other resource path</p>
    </li>
  </ul>

  <p class="fm-callout"><a id="pgfId-1014542"/><span class="fm-callout-head">Tip</span> Manually dispatching custom actions depending on the requested resource path and HTTP method is tedious. As you will see later, the <code class="fm-code-in-text1">vertx-web</code> module provides <a id="marker-1014531"/>a nicer <i class="fm-italics">router</i> API for conveniently <a id="marker-1014547"/>declaring handlers. <a id="marker-1014553"/></p>

  <p class="fm-head2"><a id="pgfId-1014560"/>The web application</p>

  <p class="body"><a id="pgfId-1014570"/><a id="marker-1014571"/>Let’s now see the client-side application, which is served by the HTTP server. The web application fits in a single HTML document shown in the following listing (I removed the irrelevant HTML portions, such as headers and footers).</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1014630"/>Listing 3.5 Web application code</p>
  <pre class="programlisting">&lt;div id="avg"&gt;&lt;/div&gt;
&lt;div id="main"&gt;&lt;/div&gt;
&lt;script language="JavaScript"&gt;
  const sse = new EventSource("/sse")                        <span class="fm-combinumeral">❶</span>
  const main = document.getElementById("main")
  const avg = document.getElementById("avg")

  sse.addEventListener("update", (evt) =&gt; {                  <span class="fm-combinumeral">❷</span>
    const data = JSON.parse(evt.data)                        <span class="fm-combinumeral">❸</span>
    let div = document.getElementById(data.id);
    if (div === null) {
      div = document.createElement("div")                    <span class="fm-combinumeral">❹</span>
      div.setAttribute("id", data.id)
      main.appendChild(div)
    }
    div.innerHTML = `&lt;strong&gt;${data.temp.toFixed(2)}&lt;/strong&gt; 
    <span class="fm-code-continuation-arrow">➥</span> (&lt;em&gt;${data.id}&lt;/em&gt;)`                                <span class="fm-combinumeral">❺</span>
  })

  sse.addEventListener("average", (evt) =&gt; {                 <span class="fm-combinumeral">❻</span>
    const data = JSON.parse(evt.data)
    avg.innerText = `Average = ${data.average.toFixed(2)}`
  })
&lt;/script&gt;</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024646"/><span class="fm-combinumeral">❶</span> EventSource objects deal with server-sent events.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024667"/><span class="fm-combinumeral">❷</span> This callback listens for server-sent events of type update.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024684"/><span class="fm-combinumeral">❸</span> The response data is plain text, and since the server will be sending JSON, we need to parse it.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024701"/><span class="fm-combinumeral">❹</span> If the sensor doesn’t have a div for displaying its data, we create it.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024718"/><span class="fm-combinumeral">❺</span> This updates a temperature div.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024735"/><span class="fm-combinumeral">❻</span> This callback listens to server-sent events of type average.</p>

  <p class="body"><a id="pgfId-1014935"/>The JavaScript code in the preceding listing deals with server-sent events and reacts to update the displayed content. We could have used one of the many popular JavaScript frameworks, but sometimes it’s good to get back to basics.</p>

  <p class="fm-callout"><a id="pgfId-1014951"/><span class="fm-callout-head">Note</span> You may have noticed that listing 3.5 uses a modern version of JavaScript, with <i class="fm-italics">arrow functions</i>, no semicolons<a id="marker-1014962"/>, and string templates. This code should work as is on any recent web browser. I tested it with Mozilla Firefox 63, Safari 12, and Google Chrome 70. <a id="marker-1014968"/></p>

  <p class="fm-head2"><a id="pgfId-1014975"/>Supporting server-sent events</p>

  <p class="body"><a id="pgfId-1014985"/><a id="marker-1014986"/>Let’s now focus on how server-sent events work, and how they can be easily implemented with Vert.x.</p>

  <p class="body"><a id="pgfId-1014994"/>Server-sent events are a very simple yet effective protocol for a server to push events to its clients. The protocol is text-based, and each event is a block with an event type and some data:</p>
  <pre class="programlisting">event: foo
data: bar</pre>

  <p class="body"><a id="pgfId-1015020"/>Each block event is separated by an empty line, so two successive events look like this:</p>
  <pre class="programlisting">event: foo
data: abc

event: bar
data: 123</pre>

  <p class="body"><a id="pgfId-1015063"/>Implementing server-sent events with Vert.x is very easy.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015120"/>Listing 3.6 Supporting server-sent events</p>
  <pre class="programlisting">private void sse(HttpServerRequest request) {
  HttpServerResponse response = request.response();
  response
    .putHeader("Content-Type", "text/event-stream")             <span class="fm-combinumeral">❶</span>
    .putHeader("Cache-Control", "no-cache")                     <span class="fm-combinumeral">❷</span>
    .setChunked(true);

  MessageConsumer&lt;JsonObject&gt; consumer = 
  <span class="fm-code-continuation-arrow">➥</span> vertx.eventBus().consumer("sensor.updates");               <span class="fm-combinumeral">❸</span>
  consumer.handler(msg -&gt; {
    response.write("event: update\n");                          <span class="fm-combinumeral">❹</span>
    response.write("data: " + msg.body().encode() + "\n\n");
  });

  TimeoutStream ticks = vertx.periodicStream(1000);             <span class="fm-combinumeral">❺</span>
  ticks.handler(id -&gt; {
    vertx.eventBus().&lt;JsonObject&gt;request("sensor.average", "", 
    <span class="fm-code-continuation-arrow">➥</span> reply -&gt; {                                               <span class="fm-combinumeral">❻</span>
      if (reply.succeeded()) {
        response.write("event: average\n");
        response.write("data: " + reply.result().body().encode() + "\n\n");
      }
    });
  });

  response.endHandler(v -&gt; {                                    <span class="fm-combinumeral">❼</span>
    consumer.unregister();
    ticks.cancel();
  });
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024081"/><span class="fm-combinumeral">❶</span> The text/event-stream MIME type is specified for server-sent events.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024109"/><span class="fm-combinumeral">❷</span> Since this is a live stream, we need to prevent browsers and proxies from caching it.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024126"/><span class="fm-combinumeral">❸</span> We call consumer without a handler, as we need an object to cancel the subscription when the client disconnects.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024143"/><span class="fm-combinumeral">❹</span> Sending event blocks is just sending text.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024323"/><span class="fm-combinumeral">❺</span> We update the average every second, so we need a periodic timer. Since it needs to be cancelled, we also use a form without a handler to get an object.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024160"/><span class="fm-combinumeral">❻</span> request sends a message that expects a response. The reply is an asynchronous object, as it may have failed.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1024177"/><span class="fm-combinumeral">❼</span> When the client disconnects (or refreshes the page) we need to unregister the event-bus message consumer and cancel the periodic task that computes averages.</p>

  <p class="body"><a id="pgfId-1015502"/>Listing 3.6 provides the implementation of the <code class="fm-code-in-text">sse</code> method that deals with HTTP requests to the <code class="fm-code-in-text">/sse</code> resource. It declares one consumer for each HTTP request for temperature updates, and it pushes new events. It also declares a periodic task to query the <code class="fm-code-in-text">SensorData</code> verticle and maintain <a id="marker-1024267"/>the average in a request-reply manner.</p>

  <p class="body"><a id="pgfId-1015517"/>Since these two handlers are for an HTTP request, we need to be able to stop them when the connection is lost. This may happen because a web browser tab is closed, or simply on page reloads. To do that, we obtain <i class="fm-italics">stream</i> objects, and <a id="marker-1023373"/>we declare a handler for each, just like we would with forms that accept callbacks. You will see in the next chapter how to deal with stream objects, and when they are useful.</p>

  <p class="body"><a id="pgfId-1015538"/>We can also use a command-line tool, such as HTTPie or curl, against the running application to see the event stream, as in the following listing.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015595"/>Listing 3.7 Stream of SSE events using HTTPie</p>
  <pre class="programlisting">$ http http://localhost:8080/sse --stream     <span class="fm-combinumeral">❶</span>
HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: text/event-stream
Transfer-Encoding: chunked

event: average                                <span class="fm-combinumeral">❷</span>
data: {"average":21.132465880152044}          <span class="fm-combinumeral">❸</span>

event: update
data: {"id":"3fa8321d-7600-42d3-b114-9fb6cdab7ecd","temp":21.043921061475107}

event: update
data: {"id":"8626e13f-9114-4f7d-acc3-bd60b00f3028","temp":21.47111113365458}

event: average
data: {"average":21.123126848463464}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023886"/><span class="fm-combinumeral">❶</span> The --stream flag allows streaming the response to the console rather than waiting for the server to end the connection.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023907"/><span class="fm-combinumeral">❷</span> Each event has a type.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023924"/><span class="fm-combinumeral">❸</span> Since JSON is just text, it transports well as event data.</p>

  <p class="fm-callout"><a id="pgfId-1015806"/><span class="fm-callout-head">Warning</span> At the time of writing, server-sent events are supported by all major web browsers except those from Microsoft. There are some JavaScript <i class="fm-italics">polyfills</i> that provide <a id="marker-1015817"/>the missing functionality to Microsoft’s browsers, albeit with some limitations. <a id="marker-1015823"/><a id="marker-1015826"/><a id="marker-1015828"/></p>

  <h3 class="fm-head1" id="heading_id_13"><a id="pgfId-1015834"/>3.2.5 Bootstrapping the application</h3>

  <p class="body"><a id="pgfId-1015844"/><a id="marker-1015845"/>Now that we have all the verticles ready, we can assemble them as a Vert.x application. The following listing shows a main class for bootstrapping the application. It deploys four sensor verticles and one instance of each other verticle.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1015904"/>Listing 3.8 Main class to bootstrap the application</p>
  <pre class="programlisting">public class Main {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle("chapter3.HeatSensor", new 
    <span class="fm-code-continuation-arrow">➥</span> DeploymentOptions().setInstances(4));          <span class="fm-combinumeral">❶</span>
    vertx.deployVerticle("chapter3.Listener");        <span class="fm-combinumeral">❷</span>
    vertx.deployVerticle("chapter3.SensorData");
    vertx.deployVerticle("chapter3.HttpServer");
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023768"/><span class="fm-combinumeral">❶</span> We start four sensors.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023789"/><span class="fm-combinumeral">❷</span> We are using the variants of deployVerticle that use reflection <a id="marker-1023794"/>to instantiate the verticle classes.</p>

  <p class="body"><a id="pgfId-1016054"/>Running the <code class="fm-code-in-text">main</code> method of this class <a id="marker-1016065"/>allows us to connect with a web browser to http://localhost:8080/. When you do, you should see a graphical interface similar to that in figure 3.4, with continuous live updates. The console logs will also display temperature updates. <a id="marker-1016072"/><a id="marker-1016075"/></p>

  <h2 class="fm-head" id="heading_id_14"><a id="pgfId-1016081"/>3.3 Clustering and the distributed event bus</h2>

  <p class="body"><a id="pgfId-1016117"/>Our use of the event bus so far has been <i class="fm-italics">local</i>: all communications happened within the same JVM process. What is even more interesting is to use Vert.x <i class="fm-italics">clustering</i> and benefit from a <i class="fm-italics">distributed</i> event bus.</p>

  <h3 class="fm-head1" id="heading_id_15"><a id="pgfId-1016126"/>3.3.1 Clustering in Vert.x</h3>

  <p class="body"><a id="pgfId-1016136"/><a id="marker-1016137"/>Vert.x applications can run in clustering mode where a set of Vert.x application nodes can work together over the network. They may be node instances of the same application and have the same set of deployed verticles, but this is not a requirement. Some nodes can have one set of verticles, while others have a different set.</p>

  <p class="body"><a id="pgfId-1016145"/>Figure 3.6 shows an overview of Vert.x clustering. A <i class="fm-italics">cluster manager</i> ensures nodes <a id="marker-1016156"/>can exchange messages over the event bus, enabling the following set of functionalities:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1016166"/>Group membership and discovery allow discovering new nodes, maintaining the list of current nodes, and detecting when nodes disappear.</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1016180"/>Shared data allows maps and counters to be maintained cluster-wide, so that all nodes share the same values. Distributed locks are useful for some forms of coordination between nodes.</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1016190"/>Subscriber topology allows knowing what event-bus destinations each node has interest in. This is useful for efficiently dispatching messages over the distributed event bus. If one node has no consumer on destination <code class="fm-code-in-text">a.b.c</code>, there is no point in sending events from that destination to that node.</p>
    </li>
  </ul>

  <p class="body"><a id="pgfId-1016219"/>There are several cluster manager implementations for Vert.x based on Hazelcast, Infinispan, Apache Ignite, and Apache ZooKeeper. Historically Hazelcast was the cluster manager for Vert.x, and then other engines were added. They all support the same Vert.x clustering abstractions for membership, shared data, and event-bus message passing. They are all functionally equivalent, so you will have to choose one depending on your needs and constraints. If you have no idea which one to pick, I recommend going with Hazelcast, which is a good default.</p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F06_Ponge.png" width="998" height="612"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027148"/>Figure 3.6 Overview of Vert.x clustering</p>

  <p class="body"><a id="pgfId-1016239"/>Finally, as shown in figure 3.6, the event-bus communications between nodes happen through direct TCP connections, using a custom protocol. When a node sends a message to a destination, it checks the subscriber topology with the cluster manager and dispatches the message to the nodes that have subscribers for that destination.</p>

  <div class="fm-sidebar-block">
    <p class="fm-sidebar-title"><a class="calibre9" id="pgfId-1027191"/>What cluster manager should you use?</p>

    <p class="fm-sidebar-text"><a id="pgfId-1027192"/>There is no good answer to the question of which cluster manager you should use. It depends on whether you need special integration with one library, and also on what type of environment you need to deploy. If, say, you need to use the Infinispan APIs in your code, and not just Infinispan as the cluster manager engine for Vert.x, you should go with Infinispan to cover both needs.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1027193"/>You should also consider your deployment environment. If you deploy to some environment where Apache ZooKeeper is being used, perhaps it would be a good choice to also rely on it for the Vert.x cluster manager.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1027194"/>By default, some cluster managers use multicast communications for node discovery, which may be disabled on some networks, especially those found in containerized environments like Kubernetes. In this case, you will need to configure the cluster manager to work in these environments.</p>

    <p class="fm-sidebar-text"><a id="pgfId-1027195"/>As mentioned earlier, in case of doubt, choose Hazelcast, and check the project documentation for specific network configuration, like when deploying to Kubernetes. You can always change to another cluster manager implementation later. <a id="marker-1027196"/></p>
  </div>

  <h3 class="fm-head1" id="heading_id_16"><a id="pgfId-1016282"/>3.3.2 From event bus to distributed event bus</h3>

  <p class="body"><a id="pgfId-1016292"/><a id="marker-1016293"/>Let’s get back to the heat sensor application that we developed earlier in this chapter. Moving to a distributed event bus is transparent for the verticles.</p>

  <p class="body"><a id="pgfId-1016301"/>We will prepare two main classes with different verticle deployments, as illustrated in figure 3.7:</p>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1016337"/>Four instances of <code class="fm-code-in-text">HeatSensor</code>, and one <a class="calibre9" id="marker-1016326"/>instance of <code class="fm-code-in-text">HttpServer</code> on port 8080</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1016386"/>Four instances of <code class="fm-code-in-text">HeatSensor</code>, one instance of <code class="fm-code-in-text">Listener</code>, one instance of <code class="fm-code-in-text">SensorData</code>, and one instance of <code class="fm-code-in-text">HttpServer</code> on port 8081 (so you can run and test it on the same host)</p>
    </li>
  </ul>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F07_Ponge.png" width="960" height="493"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027229"/>Figure 3.7 Clustered application overview</p>

  <p class="body"><a id="pgfId-1016405"/>The goal is to show that by launching one instance of each deployment in clustering mode, verticles communicate just as if they were running within the same JVM process. Connecting with a web browser to either of the instances will give the same view of the eight sensors’ data. Similarly, the <code class="fm-code-in-text">Listener</code> verticle on the second <a id="marker-1016430"/>instance will get temperature updates from the first instance.</p>

  <p class="body"><a id="pgfId-1016440"/>We will use Infinispan as the cluster manager, but you can equally use another one. Supposing your project is built with Gradle, you’ll need to add <code class="fm-code-in-text">vertx-infinispan</code> as a dependency<a id="marker-1016451"/>:</p>
  <pre class="programlisting">implementation("io.vertx:vertx-infinispan:version")</pre>

  <p class="body"><a id="pgfId-1016475"/>The following listing shows the implementation of the main class <code class="fm-code-in-text">FirstInstance</code> that we can <a id="marker-1016486"/>use to start one node that doesn’t deploy all of the application verticles.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1016547"/>Listing 3.9 Code of the main class for the first instance</p>
  <pre class="programlisting">public class FirstInstance {
  private static final Logger logger = 
  <span class="fm-code-continuation-arrow">➥</span> LoggerFactory.getLogger(FirstInstance.class);

  public static void main(String[] args) {
    Vertx.clusteredVertx(new VertxOptions(), ar -&gt; {     <span class="fm-combinumeral">❶</span>
      if (ar.succeeded()) {
        logger.info("First instance has been started");
        Vertx vertx = ar.result();                       <span class="fm-combinumeral">❷</span>
        vertx.deployVerticle("chapter3.HeatSensor", 
        <span class="fm-code-continuation-arrow">➥</span> new DeploymentOptions().setInstances(4));
        vertx.deployVerticle("chapter3.HttpServer");
      } else {
        logger.error("Could not start", ar.cause());     <span class="fm-combinumeral">❸</span>
      }
    });
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023572"/><span class="fm-combinumeral">❶</span> Starting a clustered Vert.x application is an asynchronous operation.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023596"/><span class="fm-combinumeral">❷</span> Upon success, we retrieve the Vertx instance.</p>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023613"/><span class="fm-combinumeral">❸</span> A potential cause of failure could be the absence of a cluster manager library.</p>

  <p class="body"><a id="pgfId-1016758"/>As you can see, starting an application in clustered mode <a id="marker-1016747"/>requires calling the <code class="fm-code-in-text">clusteredVertx</code> method. The remainder is just classic verticle deployment.</p>

  <p class="body"><a id="pgfId-1016767"/>The code of the second instance’s main method is very similar and is shown in the following listing.</p>

  <p class="fm-code-listing-caption"><a id="pgfId-1016824"/>Listing 3.10 Code of the main class for the second instance</p>
  <pre class="programlisting">public class SecondInstance {
  private static final Logger logger = 
  <span class="fm-code-continuation-arrow">➥</span> LoggerFactory.getLogger(SecondInstance.class);

  public static void main(String[] args) {
    Vertx.clusteredVertx(new VertxOptions(), ar -&gt; {
      if (ar.succeeded()) {
        logger.info("Second instance has been started");
        Vertx vertx = ar.result();
        vertx.deployVerticle("chapter3.HeatSensor", 
        <span class="fm-code-continuation-arrow">➥</span> new DeploymentOptions().setInstances(4));
        vertx.deployVerticle("chapter3.Listener");
        vertx.deployVerticle("chapter3.SensorData");
        JsonObject conf = new JsonObject().put("port", 8081);     <span class="fm-combinumeral">❶</span>
        vertx.deployVerticle("chapter3.HttpServer", 
        <span class="fm-code-continuation-arrow">➥</span> new DeploymentOptions().setConfig(conf));
      } else {
        logger.error("Could not start", ar.cause());
      }
    });
  }
}</pre>

  <p class="fm-code-annotation-mob"><a id="pgfId-1023513"/><span class="fm-combinumeral">❶</span> We use a different port so you can start both instances on the same host.</p>

  <p class="body"><a id="pgfId-1017012"/>Both main classes can be run on the same host, and the two instances will discover each other. As before, you can start them from your IDE, or by running <code class="fm-code-in-text">gradle run -PmainClass=chapter3.cluster.FirstInstance</code> and <code class="fm-code-in-text">gradle run -PmainClass= chapter3.cluster.SecondInstance</code> in two different terminals.</p>

  <p class="fm-callout"><a id="pgfId-1017031"/><span class="fm-callout-head">Tip</span> If you are using IPv6 and encountering issues, you can add the <code class="fm-code-in-text1">-Djava.net.preferIPv4Stack=true</code> flag to the JVM parameters.</p>

  <p class="body"><a id="pgfId-1017046"/>By default, the Vert.x Infinispan cluster manager is configured to perform discovery using network broadcast, so the two instances discover each other when they’re run on the same machine. You can also use two machines on the same network.</p>

  <p class="fm-callout"><a id="pgfId-1017312"/><span class="fm-callout-head">warning</span> Network broadcast rarely works in cloud environments and many data centers. In these cases, the cluster manager needs to be configured to use other discovery and group membership protocols. In the case of Infinispan, the documentation has specific details at <span class="fm-hyperlink"><a href="https://infinispan.org/documentation/">https://infinispan.org/documentation/</a></span>.</p>

  <p class="body"><a id="pgfId-1017358"/>Figure 3.8 shows the application running with one browser connected to the instance with port 8080 and another browser connected to the second instance with port 8081, and we see logs <a id="marker-1017337"/>from the <code class="fm-code-in-text">Listener</code> verticle in the background. As you can see, both instances display events from the eight sensors, and the first instance has its average temperature updated so it can interact with the <code class="fm-code-in-text">SensorData</code> verticle on the second instance.</p>

  <p class="fm-figure"><img alt="" class="calibre11" src="Images/CH03_F08_Ponge.png" width="996" height="645"/></p>

  <p class="fm-figure-caption"><a id="pgfId-1027271"/>Figure 3.8 Screenshot of the application running in clustered mode</p>

  <p class="body"><a id="pgfId-1017377"/>The distributed event bus is an interesting tool, as it is transparent to the verticles.</p>

  <p class="fm-callout"><a id="pgfId-1017439"/><span class="fm-callout-head">Tip</span> The event-bus API has <code class="fm-code-in-text1">localConsumer</code> methods for declaring message <a id="marker-1017418"/>handlers that only work <i class="fm-italics">locally</i> when running with clustering. For instance, a consumer for destination <code class="fm-code-in-text1">a.b.c</code> will not receive messages sent to that destination from another instance in the cluster.</p>

  <p class="body"><a id="pgfId-1017448"/>The next chapter discusses asynchronous data and event streams. <a id="marker-1017450"/></p>

  <h2 class="fm-head" id="heading_id_17"><a id="pgfId-1017457"/>Summary</h2>

  <ul class="calibre8">
    <li class="fm-list-bullet">
      <p class="list"><a class="calibre9" id="pgfId-1017467"/>The event bus is the preferred way for verticles to communicate, and it uses asynchronous message passing.</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1017481"/>The event bus implements both publish/subscribe (one-to-many) and point-to-point (many-to-one) communications.</p>
    </li>

    <li class="fm-list-bullet1">
      <p class="list"><a class="calibre9" id="pgfId-1017491"/>While it looks like a traditional message broker, the event bus does not provide durability guarantees, so it must only be used for transient data.</p>
    </li>

    <li class="fm-list-bullet-last">
      <p class="list"><a class="calibre9" id="pgfId-1017501"/>Clustering allows networked instances to communicate over the distributed event bus in a transparent fashion, and to scale the workload across several application instances.</p>
    </li>
  </ul>
  <hr class="calibre12"/>

  <p class="fm-footnote"><span class="footnotenumber">1.</span><a id="pgfId-1012188"/>For a thorough discussion of using Kafka, see Dylan Scott’s Kafka in Action (Manning, 2019).</p>

  <p class="fm-footnote"><span class="footnotenumber">2.</span><a id="pgfId-1012619"/>The W3C specification for server-sent events is available at <span class="fm-hyperlink"><a href="http://www.w3.org/TR/eventsource">www.w3.org/TR/eventsource</a></span>.</p>
</div></body>
</html>